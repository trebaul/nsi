{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Les sciences informatiques au lyc\u00e9e Voici des ressources pour mes cours en Num\u00e9rique et Sciences Informatique et en Sciences num\u00e9riques et technologie . Pour la classe de 1\u00e8re Pour la classe de terminale Je vous souhaite un bon travail !","title":"Les sciences informatiques au lyc\u00e9e"},{"location":"#les-sciences-informatiques-au-lycee","text":"Voici des ressources pour mes cours en Num\u00e9rique et Sciences Informatique et en Sciences num\u00e9riques et technologie . Pour la classe de 1\u00e8re Pour la classe de terminale Je vous souhaite un bon travail !","title":"Les sciences informatiques au lyc\u00e9e"},{"location":"about/","text":"Ing\u00e9nieure en informatique, docteure en neurosciences computationnelles et enseignante en lyc\u00e9e g\u00e9n\u00e9ral. Des informations sur mon parcours :","title":"About"},{"location":"ressources/","text":"Ressources","title":"Ressources"},{"location":"ressources/#ressources","text":"","title":"Ressources"},{"location":"tle/","text":"Les cours de terminale Le cours est divis\u00e9 selon les s\u00e9quences suivantes : 1. Paradigmes et Programmation Orient\u00e9e Objet Les \u00e9preuves du bacaclaur\u00e9at Trois \u00e9preuves de NSI sont pr\u00e9par\u00e9es pour le baccalaur\u00e9at : - l' \u00e9preuve \u00e9crite (3h30, au mois de mars) , - l' \u00e9preuve pratique (1h, au mois de mars) , - le grand oral (20min, au moins de juin) . Les ressources pour l'orientation","title":"Les cours de terminale"},{"location":"tle/#les-cours-de-terminale","text":"Le cours est divis\u00e9 selon les s\u00e9quences suivantes : 1. Paradigmes et Programmation Orient\u00e9e Objet","title":"Les cours de terminale"},{"location":"tle/#les-epreuves-du-bacaclaureat","text":"Trois \u00e9preuves de NSI sont pr\u00e9par\u00e9es pour le baccalaur\u00e9at : - l' \u00e9preuve \u00e9crite (3h30, au mois de mars) , - l' \u00e9preuve pratique (1h, au mois de mars) , - le grand oral (20min, au moins de juin) .","title":"Les \u00e9preuves du bacaclaur\u00e9at"},{"location":"tle/#les-ressources-pour-lorientation","text":"","title":"Les ressources pour l'orientation"},{"location":"1ere/seq1/archi/","text":"body { text-align: justify} S\u00e9quence 1 II. L'architecture mat\u00e9rielle des ordinateurs Cours A. Les circuits Un ordinateur fonctionne avec des 0 et des 1 , qu'il faut repr\u00e9senter de mani\u00e8re physique. Avant d'utiliser des transistors, les ordinateurs \u00e9taient \u00e9quip\u00e9s de tubes \u00e0 vide (tous deux sont des composants \u00e9lectroniques). L'apparition des transistors a permis de miniaturiser les machines. Dans les diff\u00e9rents cas, le passage d'un courant repr\u00e9sente le 1 , alors que l'absence de courant repr\u00e9sente le 0 . Les transistors peuvent aujourd'hui \u00eatre aussi petit que 10 nanom\u00e8tres, on ne les distingue pas \u00e0 l'oeil nu. Ils sont agenc\u00e9s les uns \u00e0 c\u00f4t\u00e9 des autres et reli\u00e9s sur des circuits int\u00e9gr\u00e9s . Les circuits les plus simples sont les circuits logiques , faits \u00e0 partir de portes logiques qui permettent de r\u00e9aliser des op\u00e9rations bool\u00e9ennes. En combinant des circuits logiques, on parvient \u00e0 fabriquer les circuits essentiels au fonctionnement de l'ordinateur, comme la m\u00e9moire et le processeur. B. Les principaux composants de l'ordinateur B.1. La m\u00e9moire Il existe diff\u00e9rents types de m\u00e9moires. Globalement, on regroupe : La m\u00e9moire vive ou RAM (Random Access Memory) : Elle peut se repr\u00e9senter comme des tableaux d\u2019octets, chacun identifi\u00e9 par une adresse. A cause des composants \u00e9lectroniques utilis\u00e9s, il faut une alimentation \u00e9lectrique pour conserver les donn\u00e9es. C\u2019est pour cela que la m\u00e9moire vive est volatile : les donn\u00e9es sont perdues en cas de coupure de courant. Elle permet d\u2019acc\u00e9der aux donn\u00e9es en lecture et en \u00e9criture avec une vitesse relativement rapide. la m\u00e9moire morte ou ROM (Read-Only Memory) : Elle sert \u00e0 stocker les programmes qui ne doivent pas \u00eatre modif\u00e9s et n'est donc accessible qu'en lecture . Elle contient le n\u00e9cessaire pour faire d\u00e9marrer un ordinateur, et est non-volatile . La m\u00e9moire de masse : C'est une m\u00e9moire non-volatile , \u00e0 laquelle on peut acc\u00e9der en lecture et en \u00e9criture . Elle permet de stocker une grande quantit\u00e9 de donn\u00e9es, mais n'y acc\u00e8de pas rapidement. Ce sont les disques durs SSD ou HDD ou bien les cl\u00e9s USB par exemple. Plus on s'\u00e9loigne du processeur, plus la capacit\u00e9 de la m\u00e9moire utilis\u00e9e augmente et plus le temps d'acc\u00e8s aux donn\u00e9es s'allonge. B.2. Le processeur Les instructions des programmes sont ex\u00e9cut\u00e9es par le processeur ou CPU (Central Processing Unit) en anglais. Il est qualifi\u00e9 de microprocesseur lorsque tous ses composants sont suffisamment petits pour \u00eatre regroup\u00e9s dans un m\u00eame bo\u00eetier. Il est constitu\u00e9 de 3 parties : - les registres qui correspondent \u00e0 une petite quantit\u00e9 de m\u00e9moire. Leur nombre et taille varient en fonction du type de CPU. Ils sont typiquement nomm\u00e9s R1, R2, R3,... - l\u2019 Unit\u00e9 Arithm\u00e9tique et Logique (UAL ou ALU en anglais), qui est charg\u00e9e de l\u2019ex\u00e9cution des calculs. Elle est compos\u00e9e de circuits comme l\u2019additionneur de la partie pr\u00e9c\u00e9dente. - l\u2019 unit\u00e9 de commande/de contr\u00f4le qui coordonne l\u2019ex\u00e9cution de toutes les op\u00e9rations. Le rythme auquel les instructions sont trait\u00e9es d\u00e9pend de la fr\u00e9quence de l'horloge du processeur. Une seule instruction peut \u00eatre trait\u00e9e \u00e0 la fois, donc pour aller plus vite, il faut une grande fr\u00e9quence. C. Les architectures C.1. L'architecture de von Neumann La plupart des ordinateurs utilis\u00e9s aujourd'hui sont bas\u00e9s sur l' architecture de von Neumann , \u00e9labor\u00e9e en 1945. Il s'agit de la premi\u00e8re architecture stockant au m\u00eame endroit les donn\u00e9es et les programmes : dans la m\u00e9moire vive. Elle est constitu\u00e9e : - d'une m\u00e9moire , correspondant \u00e0 de la RAM, contenant programme et donn\u00e9es, - d'une UAL avec des registres comme un accumulateur , - d'une unit\u00e9 de commande , - d'un syst\u00e8me d\u2019 entr\u00e9es-sorties . Les entr\u00e9es et sorties permettent \u00e0 l\u2019ordinateur d\u2019interagir avec l\u2019ext\u00e9rieur. Chaque p\u00e9riph\u00e9rique est r\u00e9gi par un contr\u00f4leur (un ensemble de composants \u00e9lectroniques) adapt\u00e9, permettant d\u2019encoder et de d\u00e9coder les donn\u00e9es envoy\u00e9es et re\u00e7ues. Un p\u00e9riph\u00e9rique d'entr\u00e9e (comme une souris) permet d'obtenir des informations, alors qu'un p\u00e9riph\u00e9rique de sortie (comme un \u00e9cran) permet d'envoyer des informations vers l'ext\u00e9rieur. C.2. Connecter les composants Les donn\u00e9es circulent entre les composants de l\u2019ordinateur (principalement entre le processeur et la m\u00e9moire) gr\u00e2ce \u00e0 des bus. Il en existe 3 grands types : - les bus d\u2019adresse , transportant les adresses des cases m\u00e9moires auxquelles on veut acc\u00e9der, - les bus de donn\u00e9es , transportant les donn\u00e9es en elles-m\u00eames, - les bus de commande/contr\u00f4le synchronisant l\u2019ensemble (en indiquant le type d\u2019actions \u00e0 ex\u00e9cuter, comme la lecture ou l\u2019\u00e9criture d\u2019une donn\u00e9e en m\u00e9moire). Les diff\u00e9rents composants d\u00e9crits dans les parties pr\u00e9c\u00e9dentes, ainsi que d\u2019autres qui am\u00e9liorent les ordinateurs d\u2019aujourd\u2019hui, ont besoin d\u2019\u00eatre interconnect\u00e9s de mani\u00e8re fiable : ils sont regroup\u00e9s sur une carte m\u00e8re . Elle int\u00e8gre : le processeur, les barrettes de m\u00e9moire RAM, le(s) disque(s) dur(s), les ports d\u2019entr\u00e9e-sortie, les diff\u00e9rents p\u00e9riph\u00e9riques (lecteurs DVD, carte m\u00e9moire,...) la carte r\u00e9seau, la carte graphique, l\u2019alimentation, les syst\u00e8mes de refroidissement. C.2. Les architectures multiprocesseurs L\u2019architecture d\u00b4ecrite pr\u00e9c\u00e9demment est une architecture monoprocesseur : ne comportant qu\u2019un processeur. Pour augmenter la puissance des ordinateurs, on a mis\u00e9 pendant longtemps sur l\u2019augmentation de leur fr\u00e9quence d\u2019horloge. Celle-ci est cependant devenue de plus en plus difficile, comme illustr\u00e9 sur la figure ci-contre, \u00e0 cause d\u2019un probl\u00e8me de surchauffe. L\u2019id\u00e9e a depuis \u00e9t\u00e9 d\u2019utiliser plusieurs processeurs dans un seul ordinateur : on parle d\u2019 ordinateur multiprocesseur . Cela cr\u00e9e des probl\u00e8mes de partage de la m\u00e9moire, pour lesquels il a fallu \u00e9tablir des stat\u00e9gies. On utilise de la m\u00e9moire cache, d\u2019acc\u00e8s tr\u00e8s rapide, soit partag\u00e9e pour les diff\u00e9rents processeurs, soit d\u00e9di\u00e9e \u00e0 chacun. Il faut de plus adapter les programmes \u00e0 l'architecture. Aujourd\u2019hui, on ne se contente en fait pas de multiplier les processeurs, on utilise \u00e9galement des processeurs ayant plusieurs coeurs ( architecture multicoeur ) : plusieurs unit\u00e9s de traitement ind\u00e9pendantes. Questionnaire sur le cours A. Les circuits Faire un sch\u00e9ma permettant de placer les termes suivants : processeur, porte logique, transistor, additionneur. Votre sch\u00e9ma repr\u00e9sentera au centre le plus petit des \u00e9l\u00e9ments, et autour les \u00e9l\u00e9ments faits \u00e0 partir des autres. B. Les principaux composants de l'ordinateur B.1. La m\u00e9moire Par quelles caract\u00e9ristiques diff\u00e9rencie-t-on les diff\u00e9rents types de m\u00e9moires ? Faire un sch\u00e9ma avec ces caract\u00e9ristiques et les types de m\u00e9moires associ\u00e9s. Faire un sch\u00e9ma pouvant repr\u00e9senter la m\u00e9moire vive de l'ordinateur. B.2. Le processeur Relever les diff\u00e9rents composants d'un processeur. Lequel pourrait \u00eatre associ\u00e9, si on les comparait au corps humain, au cerveau, et lequel serait les mains ? Repr\u00e9senter des cycles d'horloge d'un processeur et indiquer \u00e0 quel moment de nouvelles op\u00e9rations sont faites. Rechercher l'ordre de grandeur en Hz de la fr\u00e9quence des processeurs actuels. C. Les architectures C.1. L'architecture de von Neumann Quelle est l'id\u00e9e nouvelle de John Von Neumann lorsqu'il propose son architecture ? Que faut-il donc ajouter aux principaux composants de l'ordinateur pour avoir une machine utilisable ? Les p\u00e9riph\u00e9riques suivants sont-ils des entr\u00e9es, des sorties, ou bien les deux ? Composant Entr\u00e9e Sortie Clavier Imprimante Scanner Disque Souris Ecran C.2. Connecter les composants Expliquer comment les diff\u00e9rents composants d'un ordinateurs sont connect\u00e9s. Compl\u00e9ter le sch\u00e9ma suivant avec des fl\u00e8ches repr\u00e9sentant les diff\u00e9rents types de bus, permettant la communication entre les composants. C.2. Les architectures multiprocesseurs Sur quel param\u00e8tre peut-on jouer pour augmenter la puissance des ordinateurs, sans toucher aux processeurs ? Pourquoi alors augmenter le nombre de processeurs ? A quel probl\u00e8me faut-il alors penser ? TD : L'additionneur binaire A. Repr\u00e9sentation \u00e9lectronique des op\u00e9rateurs bool\u00e9ens On repr\u00e9sente physiquement les bool\u00e9ens et leurs op\u00e9rateurs \u00e0 partir de transistors, de tr\u00e8s petits composants \u00e9lectroniques qui : - laissent passer le courant, qui est alors \u00e0 sa valeur maximale : c'est un 1 , qui repr\u00e9sente le True bool\u00e9en. - ou ne le laissent pas passer : c'est un 0 , qui repr\u00e9sente le False bool\u00e9en. L'impl\u00e9mentation physique des op\u00e9rateurs s'appelle des portes logiques , que l'on repr\u00e9sente classiquement de la mani\u00e8re suivante : Op\u00e9rateur bool\u00e9en Porte logique NON( A ) A ET B A OU B A XOR B En combinant ces portes logiques, on construit des circuits \u00e9lectroniques effectuant des op\u00e9rations. R\u00e9\u00e9crire la table de v\u00e9rit\u00e9 du XOR en utilisant les valeurs 0 et 1 \u00e0 la place de False et True . V\u00e9rifier que le circuit ci-dessous fait bien le calcul du XOR, en attribuant toutes les valeurs possibles (entre 0 et 1) aux entr\u00e9es A et B et en calculant la valeur de la sortie S. A partir de ce circuit, trouver l'expression bool\u00e9enne constitu\u00e9e des op\u00e9rateurs NON, ET et OU qui permet de calculer le XOR. Programmer une fonction xor prenant en param\u00e8tres deux bool\u00e9ens a et b et renvoyant un bool\u00e9en, en utilisant les op\u00e9rateurs bool\u00e9ens not , and et or . Utiliser l'expression obtenue \u00e0 la question 3. On veut programmer la fonction \u00e9quivalente xor1bit fonctionnant sur des entiers (ne prenant que les valeurs 0 ou 1 ). Pour cela : Ecrire une fonction non1bit(a) prenant un 0 ou un 1 en entr\u00e9e, et renvoyant l'oppos\u00e9. Ecrire la fonction xor1bit(a,b) , en utilisant non1bit \u00e0 la place du not , le & \u00e0 la place du and et le | \u00e0 la place du or . B. L'additionneur 1 bit Un additionneur 1 bit est un circuit permettant d'additionner deux bits entre eux. Il dispose de : Trois entr\u00e9es : - a : le premier bit, - b : le deuxi\u00e8me bit, - re : la retenue entrante (peut exister dans le cas o\u00f9 l'on combine les additionneurs) Deux sorties : - s : la somme des deux bits, - rs : la retenue sortante. Aller voir le circuit \u00e9lectronique correspondant \u00e0 l'URL suivante : https://www.cahier-nsi.fr/additionneur1bit/ Compl\u00e9ter la table de v\u00e9rit\u00e9 de l'additionneur en changeant les valeurs d'entr\u00e9e du circuit : a b re s rs 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 De cette table, d\u00e9duire combien fait 1 + 1 en binaire. On donne l'expression bool\u00e9enne de s = (a XOR b) XOR re V\u00e9rifier qu'elle convient en calculant sa valeur pour les 3 premi\u00e8res lignes de la table de v\u00e9rit\u00e9. Faire de m\u00eame avec rs = (a ET b) OU ((a XOR b) ET re) . Programmer une fonction add1bit , prenant en param\u00e8tres trois entiers a , b et la retenue re , et renvoyant en sortie s et la retenue rs . On utilisera la fonction xor1bit d\u00e9finie dans la partie A. N.B.: Pour qu'une fonction renvoie 2 valeurs en sortie, il faut les s\u00e9parer par une , , apr\u00e8s le return . TP : Programmer au plus pr\u00e8s de la machine La machine comprend un langage qui n'est constitu\u00e9 que de 0 et de 1, ce qui ne nous est pas facile \u00e0 manipuler... Pour le faire, les langages assembleur ont \u00e9t\u00e9 d\u00e9velopp\u00e9s. Ils sont proches du fonctionnement de la machine, mais utilisent des instructions qui nous sont plus compr\u00e9hensibles. Nous allons manipuler un de ces langages avec le simulateur suivant : http://www.peterhigginson.co.uk/AQA/ On retrouve les principaux composants de l'ordinateur. Identifier les diff\u00e9rentes parties du processeur. Nous allons utiliser l'\u00e9diteur situ\u00e9 \u00e0 gauche, permettant de faire de l'assembleur. Saisir les lignes suivantes : MOV R0,#42 STR R0,150 HALT Cliquer sur le bouton \"Submit\". Vous allez voir des nombres appara\u00eetre dans la m\u00e9moire : Le programme a \u00e9t\u00e9 stock\u00e9 dans la m\u00e9moire, en attendant d'\u00eatre ex\u00e9cut\u00e9. Il a \u00e9t\u00e9 stock\u00e9 sous la forme de 3 instructions machine correspondant aux 3 lignes du programme, dans 3 cases de la m\u00e9moire. Pour voir \u00e0 quoi ressemblent les instructions sous la forme de 0 et de 1, cliquer sur \"OPTIONS\" et \"binary\". Revenir \u00e0 l'affichage en d\u00e9cimal avec \"OPTIONS\" > \"signed\". Pour ex\u00e9cuter le programme charg\u00e9 en m\u00e9moire, cliquer sur le bouton \"RUN\". Pour aller plus ou moins vite, utiliser les boutons >> et <<. Que fait le programme (c'est-\u00e0-dire qu'est-ce qui a \u00e9t\u00e9 modifi\u00e9 ?) ? En d\u00e9duire ce que font les instructions MOV ( \"move\" ) et STR ( \"store\" ). Qu'y a-t-il dans le registre PC ? N.B.: Pour relancer la simulation en repartant de z\u00e9ro, il faut cliquer sur \"RESET\" et sur \"OPTIONS\" > \"clear memory\". Cela r\u00e9initialisera le contenu des registres et de la m\u00e9moire. Il faut ensuite cliquer sur \"ASSEMBLE\" avant de relancer. Modifiez le programme pr\u00e9c\u00e9dent pour qu'\u00e0 la fin de l'ex\u00e9cution on trouve le nombre 54 \u00e0 l'adresse m\u00e9moire 50. On utilisera le registre R1 \u00e0 la place de R0. Testez vos modifications en ex\u00e9cutant la simulation. Saisir le programme suivant : MOV R0, #4 STR R0,30 MOV R0, #8 STR R0,75 LDR R0,30 CMP R0, #10 BNE else MOV R0, #9 STR R0,75 B endif else: LDR R0,30 ADD R0, R0, #1 STR R0,30 endif: MOV R0, #6 STR R0,23 HALT Indiquer les cases m\u00e9moires qui sont modifi\u00e9es au fur et \u00e0 mesure : adresse valeur Que fait l'instruction STR R0,75 ? L'ensemble des lignes d'instructions est-il ex\u00e9cut\u00e9 ? Si non, lesquelles ne le sont pas ? Faire une hypoth\u00e8se sur ce que font les instructions CMP et BNE. V\u00e9rifier gr\u00e2ce \u00e0 une recherche Web. En d\u00e9duire ce que fait ce programme. Donner son code \u00e9quivalent en Python.","title":"I. Architecture des ordinateurs"},{"location":"1ere/seq1/archi/#sequence-1","text":"","title":"S\u00e9quence 1"},{"location":"1ere/seq1/archi/#ii-larchitecture-materielle-des-ordinateurs","text":"","title":"II. L'architecture mat\u00e9rielle des ordinateurs"},{"location":"1ere/seq1/archi/#cours","text":"","title":"Cours"},{"location":"1ere/seq1/archi/#a-les-circuits","text":"Un ordinateur fonctionne avec des 0 et des 1 , qu'il faut repr\u00e9senter de mani\u00e8re physique. Avant d'utiliser des transistors, les ordinateurs \u00e9taient \u00e9quip\u00e9s de tubes \u00e0 vide (tous deux sont des composants \u00e9lectroniques). L'apparition des transistors a permis de miniaturiser les machines. Dans les diff\u00e9rents cas, le passage d'un courant repr\u00e9sente le 1 , alors que l'absence de courant repr\u00e9sente le 0 . Les transistors peuvent aujourd'hui \u00eatre aussi petit que 10 nanom\u00e8tres, on ne les distingue pas \u00e0 l'oeil nu. Ils sont agenc\u00e9s les uns \u00e0 c\u00f4t\u00e9 des autres et reli\u00e9s sur des circuits int\u00e9gr\u00e9s . Les circuits les plus simples sont les circuits logiques , faits \u00e0 partir de portes logiques qui permettent de r\u00e9aliser des op\u00e9rations bool\u00e9ennes. En combinant des circuits logiques, on parvient \u00e0 fabriquer les circuits essentiels au fonctionnement de l'ordinateur, comme la m\u00e9moire et le processeur.","title":"A. Les circuits"},{"location":"1ere/seq1/archi/#b-les-principaux-composants-de-lordinateur","text":"","title":"B. Les principaux composants de l'ordinateur"},{"location":"1ere/seq1/archi/#b1-la-memoire","text":"Il existe diff\u00e9rents types de m\u00e9moires. Globalement, on regroupe : La m\u00e9moire vive ou RAM (Random Access Memory) : Elle peut se repr\u00e9senter comme des tableaux d\u2019octets, chacun identifi\u00e9 par une adresse. A cause des composants \u00e9lectroniques utilis\u00e9s, il faut une alimentation \u00e9lectrique pour conserver les donn\u00e9es. C\u2019est pour cela que la m\u00e9moire vive est volatile : les donn\u00e9es sont perdues en cas de coupure de courant. Elle permet d\u2019acc\u00e9der aux donn\u00e9es en lecture et en \u00e9criture avec une vitesse relativement rapide. la m\u00e9moire morte ou ROM (Read-Only Memory) : Elle sert \u00e0 stocker les programmes qui ne doivent pas \u00eatre modif\u00e9s et n'est donc accessible qu'en lecture . Elle contient le n\u00e9cessaire pour faire d\u00e9marrer un ordinateur, et est non-volatile . La m\u00e9moire de masse : C'est une m\u00e9moire non-volatile , \u00e0 laquelle on peut acc\u00e9der en lecture et en \u00e9criture . Elle permet de stocker une grande quantit\u00e9 de donn\u00e9es, mais n'y acc\u00e8de pas rapidement. Ce sont les disques durs SSD ou HDD ou bien les cl\u00e9s USB par exemple. Plus on s'\u00e9loigne du processeur, plus la capacit\u00e9 de la m\u00e9moire utilis\u00e9e augmente et plus le temps d'acc\u00e8s aux donn\u00e9es s'allonge.","title":"B.1. La m\u00e9moire"},{"location":"1ere/seq1/archi/#b2-le-processeur","text":"Les instructions des programmes sont ex\u00e9cut\u00e9es par le processeur ou CPU (Central Processing Unit) en anglais. Il est qualifi\u00e9 de microprocesseur lorsque tous ses composants sont suffisamment petits pour \u00eatre regroup\u00e9s dans un m\u00eame bo\u00eetier. Il est constitu\u00e9 de 3 parties : - les registres qui correspondent \u00e0 une petite quantit\u00e9 de m\u00e9moire. Leur nombre et taille varient en fonction du type de CPU. Ils sont typiquement nomm\u00e9s R1, R2, R3,... - l\u2019 Unit\u00e9 Arithm\u00e9tique et Logique (UAL ou ALU en anglais), qui est charg\u00e9e de l\u2019ex\u00e9cution des calculs. Elle est compos\u00e9e de circuits comme l\u2019additionneur de la partie pr\u00e9c\u00e9dente. - l\u2019 unit\u00e9 de commande/de contr\u00f4le qui coordonne l\u2019ex\u00e9cution de toutes les op\u00e9rations. Le rythme auquel les instructions sont trait\u00e9es d\u00e9pend de la fr\u00e9quence de l'horloge du processeur. Une seule instruction peut \u00eatre trait\u00e9e \u00e0 la fois, donc pour aller plus vite, il faut une grande fr\u00e9quence.","title":"B.2. Le processeur"},{"location":"1ere/seq1/archi/#c-les-architectures","text":"","title":"C. Les architectures"},{"location":"1ere/seq1/archi/#c1-larchitecture-de-von-neumann","text":"La plupart des ordinateurs utilis\u00e9s aujourd'hui sont bas\u00e9s sur l' architecture de von Neumann , \u00e9labor\u00e9e en 1945. Il s'agit de la premi\u00e8re architecture stockant au m\u00eame endroit les donn\u00e9es et les programmes : dans la m\u00e9moire vive. Elle est constitu\u00e9e : - d'une m\u00e9moire , correspondant \u00e0 de la RAM, contenant programme et donn\u00e9es, - d'une UAL avec des registres comme un accumulateur , - d'une unit\u00e9 de commande , - d'un syst\u00e8me d\u2019 entr\u00e9es-sorties . Les entr\u00e9es et sorties permettent \u00e0 l\u2019ordinateur d\u2019interagir avec l\u2019ext\u00e9rieur. Chaque p\u00e9riph\u00e9rique est r\u00e9gi par un contr\u00f4leur (un ensemble de composants \u00e9lectroniques) adapt\u00e9, permettant d\u2019encoder et de d\u00e9coder les donn\u00e9es envoy\u00e9es et re\u00e7ues. Un p\u00e9riph\u00e9rique d'entr\u00e9e (comme une souris) permet d'obtenir des informations, alors qu'un p\u00e9riph\u00e9rique de sortie (comme un \u00e9cran) permet d'envoyer des informations vers l'ext\u00e9rieur.","title":"C.1. L'architecture de von Neumann"},{"location":"1ere/seq1/archi/#c2-connecter-les-composants","text":"Les donn\u00e9es circulent entre les composants de l\u2019ordinateur (principalement entre le processeur et la m\u00e9moire) gr\u00e2ce \u00e0 des bus. Il en existe 3 grands types : - les bus d\u2019adresse , transportant les adresses des cases m\u00e9moires auxquelles on veut acc\u00e9der, - les bus de donn\u00e9es , transportant les donn\u00e9es en elles-m\u00eames, - les bus de commande/contr\u00f4le synchronisant l\u2019ensemble (en indiquant le type d\u2019actions \u00e0 ex\u00e9cuter, comme la lecture ou l\u2019\u00e9criture d\u2019une donn\u00e9e en m\u00e9moire). Les diff\u00e9rents composants d\u00e9crits dans les parties pr\u00e9c\u00e9dentes, ainsi que d\u2019autres qui am\u00e9liorent les ordinateurs d\u2019aujourd\u2019hui, ont besoin d\u2019\u00eatre interconnect\u00e9s de mani\u00e8re fiable : ils sont regroup\u00e9s sur une carte m\u00e8re . Elle int\u00e8gre : le processeur, les barrettes de m\u00e9moire RAM, le(s) disque(s) dur(s), les ports d\u2019entr\u00e9e-sortie, les diff\u00e9rents p\u00e9riph\u00e9riques (lecteurs DVD, carte m\u00e9moire,...) la carte r\u00e9seau, la carte graphique, l\u2019alimentation, les syst\u00e8mes de refroidissement.","title":"C.2. Connecter les composants"},{"location":"1ere/seq1/archi/#c2-les-architectures-multiprocesseurs","text":"L\u2019architecture d\u00b4ecrite pr\u00e9c\u00e9demment est une architecture monoprocesseur : ne comportant qu\u2019un processeur. Pour augmenter la puissance des ordinateurs, on a mis\u00e9 pendant longtemps sur l\u2019augmentation de leur fr\u00e9quence d\u2019horloge. Celle-ci est cependant devenue de plus en plus difficile, comme illustr\u00e9 sur la figure ci-contre, \u00e0 cause d\u2019un probl\u00e8me de surchauffe. L\u2019id\u00e9e a depuis \u00e9t\u00e9 d\u2019utiliser plusieurs processeurs dans un seul ordinateur : on parle d\u2019 ordinateur multiprocesseur . Cela cr\u00e9e des probl\u00e8mes de partage de la m\u00e9moire, pour lesquels il a fallu \u00e9tablir des stat\u00e9gies. On utilise de la m\u00e9moire cache, d\u2019acc\u00e8s tr\u00e8s rapide, soit partag\u00e9e pour les diff\u00e9rents processeurs, soit d\u00e9di\u00e9e \u00e0 chacun. Il faut de plus adapter les programmes \u00e0 l'architecture. Aujourd\u2019hui, on ne se contente en fait pas de multiplier les processeurs, on utilise \u00e9galement des processeurs ayant plusieurs coeurs ( architecture multicoeur ) : plusieurs unit\u00e9s de traitement ind\u00e9pendantes.","title":"C.2. Les architectures multiprocesseurs"},{"location":"1ere/seq1/archi/#questionnaire-sur-le-cours","text":"","title":"Questionnaire sur le cours"},{"location":"1ere/seq1/archi/#a-les-circuits_1","text":"Faire un sch\u00e9ma permettant de placer les termes suivants : processeur, porte logique, transistor, additionneur. Votre sch\u00e9ma repr\u00e9sentera au centre le plus petit des \u00e9l\u00e9ments, et autour les \u00e9l\u00e9ments faits \u00e0 partir des autres.","title":"A. Les circuits"},{"location":"1ere/seq1/archi/#b-les-principaux-composants-de-lordinateur_1","text":"","title":"B. Les principaux composants de l'ordinateur"},{"location":"1ere/seq1/archi/#b1-la-memoire_1","text":"Par quelles caract\u00e9ristiques diff\u00e9rencie-t-on les diff\u00e9rents types de m\u00e9moires ? Faire un sch\u00e9ma avec ces caract\u00e9ristiques et les types de m\u00e9moires associ\u00e9s. Faire un sch\u00e9ma pouvant repr\u00e9senter la m\u00e9moire vive de l'ordinateur.","title":"B.1. La m\u00e9moire"},{"location":"1ere/seq1/archi/#b2-le-processeur_1","text":"Relever les diff\u00e9rents composants d'un processeur. Lequel pourrait \u00eatre associ\u00e9, si on les comparait au corps humain, au cerveau, et lequel serait les mains ? Repr\u00e9senter des cycles d'horloge d'un processeur et indiquer \u00e0 quel moment de nouvelles op\u00e9rations sont faites. Rechercher l'ordre de grandeur en Hz de la fr\u00e9quence des processeurs actuels.","title":"B.2. Le processeur"},{"location":"1ere/seq1/archi/#c-les-architectures_1","text":"","title":"C. Les architectures"},{"location":"1ere/seq1/archi/#c1-larchitecture-de-von-neumann_1","text":"Quelle est l'id\u00e9e nouvelle de John Von Neumann lorsqu'il propose son architecture ? Que faut-il donc ajouter aux principaux composants de l'ordinateur pour avoir une machine utilisable ? Les p\u00e9riph\u00e9riques suivants sont-ils des entr\u00e9es, des sorties, ou bien les deux ? Composant Entr\u00e9e Sortie Clavier Imprimante Scanner Disque Souris Ecran","title":"C.1. L'architecture de von Neumann"},{"location":"1ere/seq1/archi/#c2-connecter-les-composants_1","text":"Expliquer comment les diff\u00e9rents composants d'un ordinateurs sont connect\u00e9s. Compl\u00e9ter le sch\u00e9ma suivant avec des fl\u00e8ches repr\u00e9sentant les diff\u00e9rents types de bus, permettant la communication entre les composants.","title":"C.2. Connecter les composants"},{"location":"1ere/seq1/archi/#c2-les-architectures-multiprocesseurs_1","text":"Sur quel param\u00e8tre peut-on jouer pour augmenter la puissance des ordinateurs, sans toucher aux processeurs ? Pourquoi alors augmenter le nombre de processeurs ? A quel probl\u00e8me faut-il alors penser ?","title":"C.2. Les architectures multiprocesseurs"},{"location":"1ere/seq1/archi/#td-ladditionneur-binaire","text":"","title":"TD : L'additionneur binaire"},{"location":"1ere/seq1/archi/#a-representation-electronique-des-operateurs-booleens","text":"On repr\u00e9sente physiquement les bool\u00e9ens et leurs op\u00e9rateurs \u00e0 partir de transistors, de tr\u00e8s petits composants \u00e9lectroniques qui : - laissent passer le courant, qui est alors \u00e0 sa valeur maximale : c'est un 1 , qui repr\u00e9sente le True bool\u00e9en. - ou ne le laissent pas passer : c'est un 0 , qui repr\u00e9sente le False bool\u00e9en. L'impl\u00e9mentation physique des op\u00e9rateurs s'appelle des portes logiques , que l'on repr\u00e9sente classiquement de la mani\u00e8re suivante : Op\u00e9rateur bool\u00e9en Porte logique NON( A ) A ET B A OU B A XOR B En combinant ces portes logiques, on construit des circuits \u00e9lectroniques effectuant des op\u00e9rations. R\u00e9\u00e9crire la table de v\u00e9rit\u00e9 du XOR en utilisant les valeurs 0 et 1 \u00e0 la place de False et True . V\u00e9rifier que le circuit ci-dessous fait bien le calcul du XOR, en attribuant toutes les valeurs possibles (entre 0 et 1) aux entr\u00e9es A et B et en calculant la valeur de la sortie S. A partir de ce circuit, trouver l'expression bool\u00e9enne constitu\u00e9e des op\u00e9rateurs NON, ET et OU qui permet de calculer le XOR. Programmer une fonction xor prenant en param\u00e8tres deux bool\u00e9ens a et b et renvoyant un bool\u00e9en, en utilisant les op\u00e9rateurs bool\u00e9ens not , and et or . Utiliser l'expression obtenue \u00e0 la question 3. On veut programmer la fonction \u00e9quivalente xor1bit fonctionnant sur des entiers (ne prenant que les valeurs 0 ou 1 ). Pour cela : Ecrire une fonction non1bit(a) prenant un 0 ou un 1 en entr\u00e9e, et renvoyant l'oppos\u00e9. Ecrire la fonction xor1bit(a,b) , en utilisant non1bit \u00e0 la place du not , le & \u00e0 la place du and et le | \u00e0 la place du or .","title":"A. Repr\u00e9sentation \u00e9lectronique des op\u00e9rateurs bool\u00e9ens"},{"location":"1ere/seq1/archi/#b-ladditionneur-1-bit","text":"Un additionneur 1 bit est un circuit permettant d'additionner deux bits entre eux. Il dispose de : Trois entr\u00e9es : - a : le premier bit, - b : le deuxi\u00e8me bit, - re : la retenue entrante (peut exister dans le cas o\u00f9 l'on combine les additionneurs) Deux sorties : - s : la somme des deux bits, - rs : la retenue sortante. Aller voir le circuit \u00e9lectronique correspondant \u00e0 l'URL suivante : https://www.cahier-nsi.fr/additionneur1bit/ Compl\u00e9ter la table de v\u00e9rit\u00e9 de l'additionneur en changeant les valeurs d'entr\u00e9e du circuit : a b re s rs 0 0 0 0 0 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 De cette table, d\u00e9duire combien fait 1 + 1 en binaire. On donne l'expression bool\u00e9enne de s = (a XOR b) XOR re V\u00e9rifier qu'elle convient en calculant sa valeur pour les 3 premi\u00e8res lignes de la table de v\u00e9rit\u00e9. Faire de m\u00eame avec rs = (a ET b) OU ((a XOR b) ET re) . Programmer une fonction add1bit , prenant en param\u00e8tres trois entiers a , b et la retenue re , et renvoyant en sortie s et la retenue rs . On utilisera la fonction xor1bit d\u00e9finie dans la partie A. N.B.: Pour qu'une fonction renvoie 2 valeurs en sortie, il faut les s\u00e9parer par une , , apr\u00e8s le return .","title":"B. L'additionneur 1 bit"},{"location":"1ere/seq1/archi/#tp-programmer-au-plus-pres-de-la-machine","text":"La machine comprend un langage qui n'est constitu\u00e9 que de 0 et de 1, ce qui ne nous est pas facile \u00e0 manipuler... Pour le faire, les langages assembleur ont \u00e9t\u00e9 d\u00e9velopp\u00e9s. Ils sont proches du fonctionnement de la machine, mais utilisent des instructions qui nous sont plus compr\u00e9hensibles. Nous allons manipuler un de ces langages avec le simulateur suivant : http://www.peterhigginson.co.uk/AQA/ On retrouve les principaux composants de l'ordinateur. Identifier les diff\u00e9rentes parties du processeur. Nous allons utiliser l'\u00e9diteur situ\u00e9 \u00e0 gauche, permettant de faire de l'assembleur. Saisir les lignes suivantes : MOV R0,#42 STR R0,150 HALT Cliquer sur le bouton \"Submit\". Vous allez voir des nombres appara\u00eetre dans la m\u00e9moire : Le programme a \u00e9t\u00e9 stock\u00e9 dans la m\u00e9moire, en attendant d'\u00eatre ex\u00e9cut\u00e9. Il a \u00e9t\u00e9 stock\u00e9 sous la forme de 3 instructions machine correspondant aux 3 lignes du programme, dans 3 cases de la m\u00e9moire. Pour voir \u00e0 quoi ressemblent les instructions sous la forme de 0 et de 1, cliquer sur \"OPTIONS\" et \"binary\". Revenir \u00e0 l'affichage en d\u00e9cimal avec \"OPTIONS\" > \"signed\". Pour ex\u00e9cuter le programme charg\u00e9 en m\u00e9moire, cliquer sur le bouton \"RUN\". Pour aller plus ou moins vite, utiliser les boutons >> et <<. Que fait le programme (c'est-\u00e0-dire qu'est-ce qui a \u00e9t\u00e9 modifi\u00e9 ?) ? En d\u00e9duire ce que font les instructions MOV ( \"move\" ) et STR ( \"store\" ). Qu'y a-t-il dans le registre PC ? N.B.: Pour relancer la simulation en repartant de z\u00e9ro, il faut cliquer sur \"RESET\" et sur \"OPTIONS\" > \"clear memory\". Cela r\u00e9initialisera le contenu des registres et de la m\u00e9moire. Il faut ensuite cliquer sur \"ASSEMBLE\" avant de relancer. Modifiez le programme pr\u00e9c\u00e9dent pour qu'\u00e0 la fin de l'ex\u00e9cution on trouve le nombre 54 \u00e0 l'adresse m\u00e9moire 50. On utilisera le registre R1 \u00e0 la place de R0. Testez vos modifications en ex\u00e9cutant la simulation. Saisir le programme suivant : MOV R0, #4 STR R0,30 MOV R0, #8 STR R0,75 LDR R0,30 CMP R0, #10 BNE else MOV R0, #9 STR R0,75 B endif else: LDR R0,30 ADD R0, R0, #1 STR R0,30 endif: MOV R0, #6 STR R0,23 HALT Indiquer les cases m\u00e9moires qui sont modifi\u00e9es au fur et \u00e0 mesure : adresse valeur Que fait l'instruction STR R0,75 ? L'ensemble des lignes d'instructions est-il ex\u00e9cut\u00e9 ? Si non, lesquelles ne le sont pas ? Faire une hypoth\u00e8se sur ce que font les instructions CMP et BNE. V\u00e9rifier gr\u00e2ce \u00e0 une recherche Web. En d\u00e9duire ce que fait ce programme. Donner son code \u00e9quivalent en Python.","title":"TP : Programmer au plus pr\u00e8s de la machine"},{"location":"1ere/seq1/logique/","text":"body { text-align: justify} S\u00e9quence 1 I. La logique bool\u00e9enne Cours Introduction L'informatique est bas\u00e9e sur l'utilisation de 1 et de 0 : ils repr\u00e9sentent le vrai et le faux, True et False en Python, et correspondent au type bool\u00e9en . Nous avons vu que les expressions bool\u00e9ennes permettent de diff\u00e9rencier diff\u00e9rents cas dans un programme. Nous avons vu des op\u00e9rateurs qui permettent de comparer des nombres ( int ou float ), et renvoient des bool\u00e9ens ( bool ). Pour combiner ces expressions bool\u00e9ennes, on utilise des op\u00e9rateurs bool\u00e9ens . Passons en revue ces op\u00e9rateurs, en consid\u00e9rant le probl\u00e8me suivant : Au milieu du d\u00e9sert, deux sphinx gardent chacun une porte. Une des deux portes continue dans le d\u00e9sert, l'autre m\u00e8ne vers une oasis. L'un des deux sphinx dit toujours la v\u00e9rit\u00e9, l'autre ment toujours. On veut savoir par o\u00f9 aller pour acc\u00e9der \u00e0 l'oasis. I.A. Le NON (NOT) L'op\u00e9rateur NON (NOT en anglais) inverse la valeur d'une variable bool\u00e9enne . Si A vaut False , non( A ) vaut True et r\u00e9ciproquement. On r\u00e9sume cela avec une table, dite table de v\u00e9rit\u00e9 de l'op\u00e9rateur NON : A NON( A ) False True True False La table de v\u00e9rit\u00e9 d'une expression bool\u00e9enne indique la valeur de l'expression pour chaque valeur possible de ses variables. Application au probl\u00e8me : On veut demander l'information, si l'on s'adresse \u00e0 celui qui dit la v\u00e9rit\u00e9 - donc \u00e0 celui qui ne ment pas. On utilise une variable bool\u00e9enne menteur qui vaut True si le sphinx auquel on s'adresse ment, False s'il dit la v\u00e9rit\u00e9 : if not(menteur): print(\"Pouvez-vous m'indiquer l'oasis ?\") I.B. Le ET (AND) L'op\u00e9rateur ET (AND en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A ET B est vrai si A est vraie et B est vraie. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A ET B False False False True False False False True False True True True Application au probl\u00e8me : Si le sphinx auquel on s'adresse n'est pas un menteur et s'il nous dit qu'il se trouve devant la porte menant \u00e0 l'oasis, on veut prendre ce chemin. On utilise une variable porte valant True si le sphinx dit qu'elle m\u00e8ne \u00e0 l'oasis, False sinon : if not(menteur) and porte: print(\"Je prends ce chemin.\") I.C. Le OU (OR) L'op\u00e9rateur OU (OR en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A OU B est vrai si A est vraie, B est vraie, ou bien les deux le sont. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A OU B False False False True False True False True True True True True Application au probl\u00e8me : Si le sphinx auquel on s'adresse n'est pas un menteur et s'il nous dit qu'il se trouve devant la porte menant \u00e0 l'oasis ou s'il est un menteur et qu'il nous dit que la porte continue dans le d\u00e9sert, on veut prendre ce chemin. if (not(menteur) and porte) or (menteur and not(porte)): print(\"Je prends ce chemin.\") \\pagebreak I.D. Le OU exclusif (XOR) L'op\u00e9rateur OU EXCLUSIF (XOR en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A OU B est vrai si A est vraie ou bien B est vraie. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A OU B False False False True False True False True True True True False Application au probl\u00e8me : Si le sphinx auquel on s'adresse est un menteur ou (exclusif) s'il nous dit qu'il ne se trouve pas devant la porte menant \u00e0 l'oasis (et donc qu'il ne ment pas), on ne veut pas prendre ce chemin. from operator import xor if xor(menteur,not(porte)): print(\"Je ne prends pas ce chemin.\") N.B. : L'utilisation de cette fonction n'est pas \u00e0 apprendre par coeur. Conclusion Une bonne utilisation des op\u00e9rateurs bool\u00e9ens permet notamment de mieux g\u00e9rer les diff\u00e9rentes conditions trait\u00e9es dans les programmes. La logique bool\u00e9enne trouve aussi des applications dans la conception de circuits \u00e9lectroniques. Nous ne savons en fait pas quel sphinx ment et lequel dit la v\u00e9rit\u00e9. Nous n'avons le droit de ne poser qu'une question \u00e0 un des deux sphinx pour savoir o\u00f9 aller. Laquelle devons-nous choisir pour aller \u00e0 coup s\u00fbr vers l'oasis ? Exercices : les expressions bool\u00e9ennes Exercice 0 (am\u00e9lioration du TP sur les fonctions) : On dispose d'une fonction pair(n) , renvoyant si un entier n est pair ou non : def pair(n): return n%2 == 0 On consid\u00e8re une variable m repr\u00e9sentant un mois de l'ann\u00e9e. Quelle instruction \u00e9crire pour tester \"m est-t-il impair\" ? Ecrire le programme Python traduisant l'algorithme suivant : Si n est impair et qu il est un mois de la fin de l ann\u00e9e nb_jours vaut 30 Faire la m\u00eame chose avec l'algorithme suivant : Si n est pair et qu il est un mois du d\u00e9but de l ann\u00e9e nb_jours vaut 30 Comment combiner les conditions des questions 2 et 3 ? Compl\u00e9ter la fonction suivante, permettant de tester tous les mois de l'ann\u00e9e : def nombre_jours(m): if m == 2: nb = 28 elif ... nb = 30 ... return nb Exercice 1 : Vrai ou Faux Si a vaut True et b vaut False , not(a or b) s'\u00e9value \u00e0 True . L'expression not(a or b) a la m\u00eame valeur que l'expression (not a) or (not b) . Si a vaut True et b vaut True , not(a and b) s'\u00e9value \u00e0 True . L'expression not(a and b) a la m\u00eame valeur que l'expression not(a) or not(b) . Exercice 2 : S\u00e9lectionner la(les) bonne(s) r\u00e9ponse(s) parmi les diff\u00e9rentes propositions. L'expression bool\u00e9enne a or not(b) s'\u00e9value \u00e0 True . Quelles peuvent \u00eatre les valeurs de a et de b ? a vaut True et b vaut True a vaut True et b vaut False a vaut False et b vaut True a vaut False et b vaut False Parmi les expressions suivantes, laquelle s'\u00e9value en True ? True and (False and True) True or (False and True) False and (False and True) False or (False and True) Exercice 3 : On consid\u00e8re l'expression a and b o\u00f9 a et b sont deux expressions bool\u00e9ennes. Si a vaut False , quelle sera la valeur de l'expression, en fonction de la valeur de b ? Que pouvez-vous en d\u00e9duire ? On consid\u00e8re l'expression a or b o\u00f9 a et b sont deux expressions bool\u00e9ennes. Si a vaut True , quelle sera la valeur de l'expression, en fonction de la valeur de b ? Que pouvez-vous en d\u00e9duire ? Conclusion (\u00e0 retenir) : TD : Qui faut-il croire ? A. Un village perdu Vous voyagez dans un endroit que vous ne connaissez pas, et demandez votre chemin \u00e0 deux locaux que vous croisez. Vous souhaitez savoir o\u00f9 se trouve le village qui est votre objectif. Ils d\u00e9cident de jouer \u00e0 un jeu avec vous : ils vont vous donner des informations, et soit toutes ces informations seront vraies, soit elles seront toutes fausses. En appliquant la logique bool\u00e9enne, vous devez \u00eatre capable d'obtenir l'information que vous recherchez. Voici leurs propos : X : \"Le village se trouve dans la vall\u00e9e.\" Y : \"Non, il ne s\u2019y trouve pas.\" X : \"Ou alors dans les collines.\" On mod\u00e9lise le probl\u00e8me avec les variables suivantes : - V et C qui valent True si, respectivement, le village se trouve dans la vall\u00e9e ou dans les collines, et False sinon, - X et Y qui valent True si respectivement les affirmations de X et de Y sont vraies, et False sinon. Traduire X et Y en fonction de V , C , et des op\u00e9rateurs bool\u00e9ens qui conviennent. Compl\u00e9ter la table de v\u00e9rit\u00e9 suivante (on part du principe que le village ne peut \u00eatre que soit dans la vall\u00e9e, soit dans la colline) : V C X Y False True True False En d\u00e9duire o\u00f9 se trouve le village. \\pagebreak B. Au tribunal Vous \u00eates dans le jury d'un tribunal et \u00e9coutez les t\u00e9moins d'une enqu\u00eate. On sait que chacun des t\u00e9moins soit toujours dit la v\u00e9rit\u00e9, soit ment toujours. Notre but est d'identifier ceux qui mentent et ceux qui ne mentent pas pour prononcer le verdict le plus juste possible. Les trois t\u00e9moins s'expriment : Ap : \"Personne ne doit croire C.\" Bp : \"A et C disent toujours la v\u00e9rit\u00e9.\" Cp : \"B dit la v\u00e9rit\u00e9.\" On mod\u00e9lise le probl\u00e8me avec les variables suivantes : A , B et C qui valent True si, respectivement, les t\u00e9moins A, B et C disent la v\u00e9rit\u00e9, et False sinon. Traduire Ap, Bp et Cp sous la forme d'expressions bool\u00e9ennes en utilisant les op\u00e9rateurs appropri\u00e9s. Compl\u00e9ter la table de v\u00e9rit\u00e9 suivante : A B C Ap Bp Cp False False False False False True False True False False True True True False False True False True True True False True True True Comment pouvez-vous en d\u00e9duire qui dit la v\u00e9rit\u00e9 et qui ment ?","title":"I. Logique"},{"location":"1ere/seq1/logique/#sequence-1","text":"","title":"S\u00e9quence 1"},{"location":"1ere/seq1/logique/#i-la-logique-booleenne","text":"","title":"I. La logique bool\u00e9enne"},{"location":"1ere/seq1/logique/#cours","text":"","title":"Cours"},{"location":"1ere/seq1/logique/#introduction","text":"L'informatique est bas\u00e9e sur l'utilisation de 1 et de 0 : ils repr\u00e9sentent le vrai et le faux, True et False en Python, et correspondent au type bool\u00e9en . Nous avons vu que les expressions bool\u00e9ennes permettent de diff\u00e9rencier diff\u00e9rents cas dans un programme. Nous avons vu des op\u00e9rateurs qui permettent de comparer des nombres ( int ou float ), et renvoient des bool\u00e9ens ( bool ). Pour combiner ces expressions bool\u00e9ennes, on utilise des op\u00e9rateurs bool\u00e9ens . Passons en revue ces op\u00e9rateurs, en consid\u00e9rant le probl\u00e8me suivant : Au milieu du d\u00e9sert, deux sphinx gardent chacun une porte. Une des deux portes continue dans le d\u00e9sert, l'autre m\u00e8ne vers une oasis. L'un des deux sphinx dit toujours la v\u00e9rit\u00e9, l'autre ment toujours. On veut savoir par o\u00f9 aller pour acc\u00e9der \u00e0 l'oasis.","title":"Introduction"},{"location":"1ere/seq1/logique/#ia-le-non-not","text":"L'op\u00e9rateur NON (NOT en anglais) inverse la valeur d'une variable bool\u00e9enne . Si A vaut False , non( A ) vaut True et r\u00e9ciproquement. On r\u00e9sume cela avec une table, dite table de v\u00e9rit\u00e9 de l'op\u00e9rateur NON : A NON( A ) False True True False La table de v\u00e9rit\u00e9 d'une expression bool\u00e9enne indique la valeur de l'expression pour chaque valeur possible de ses variables. Application au probl\u00e8me : On veut demander l'information, si l'on s'adresse \u00e0 celui qui dit la v\u00e9rit\u00e9 - donc \u00e0 celui qui ne ment pas. On utilise une variable bool\u00e9enne menteur qui vaut True si le sphinx auquel on s'adresse ment, False s'il dit la v\u00e9rit\u00e9 : if not(menteur): print(\"Pouvez-vous m'indiquer l'oasis ?\")","title":"I.A. Le NON (NOT)"},{"location":"1ere/seq1/logique/#ib-le-et-and","text":"L'op\u00e9rateur ET (AND en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A ET B est vrai si A est vraie et B est vraie. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A ET B False False False True False False False True False True True True Application au probl\u00e8me : Si le sphinx auquel on s'adresse n'est pas un menteur et s'il nous dit qu'il se trouve devant la porte menant \u00e0 l'oasis, on veut prendre ce chemin. On utilise une variable porte valant True si le sphinx dit qu'elle m\u00e8ne \u00e0 l'oasis, False sinon : if not(menteur) and porte: print(\"Je prends ce chemin.\")","title":"I.B. Le ET (AND)"},{"location":"1ere/seq1/logique/#ic-le-ou-or","text":"L'op\u00e9rateur OU (OR en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A OU B est vrai si A est vraie, B est vraie, ou bien les deux le sont. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A OU B False False False True False True False True True True True True Application au probl\u00e8me : Si le sphinx auquel on s'adresse n'est pas un menteur et s'il nous dit qu'il se trouve devant la porte menant \u00e0 l'oasis ou s'il est un menteur et qu'il nous dit que la porte continue dans le d\u00e9sert, on veut prendre ce chemin. if (not(menteur) and porte) or (menteur and not(porte)): print(\"Je prends ce chemin.\") \\pagebreak","title":"I.C. Le OU (OR)"},{"location":"1ere/seq1/logique/#id-le-ou-exclusif-xor","text":"L'op\u00e9rateur OU EXCLUSIF (XOR en anglais) permet d'associer deux expressions bool\u00e9ennes de la mani\u00e8re suivante : A OU B est vrai si A est vraie ou bien B est vraie. Cela donne la table de v\u00e9rit\u00e9 suivante : A B A OU B False False False True False True False True True True True False Application au probl\u00e8me : Si le sphinx auquel on s'adresse est un menteur ou (exclusif) s'il nous dit qu'il ne se trouve pas devant la porte menant \u00e0 l'oasis (et donc qu'il ne ment pas), on ne veut pas prendre ce chemin. from operator import xor if xor(menteur,not(porte)): print(\"Je ne prends pas ce chemin.\") N.B. : L'utilisation de cette fonction n'est pas \u00e0 apprendre par coeur.","title":"I.D. Le OU exclusif (XOR)"},{"location":"1ere/seq1/logique/#conclusion","text":"Une bonne utilisation des op\u00e9rateurs bool\u00e9ens permet notamment de mieux g\u00e9rer les diff\u00e9rentes conditions trait\u00e9es dans les programmes. La logique bool\u00e9enne trouve aussi des applications dans la conception de circuits \u00e9lectroniques. Nous ne savons en fait pas quel sphinx ment et lequel dit la v\u00e9rit\u00e9. Nous n'avons le droit de ne poser qu'une question \u00e0 un des deux sphinx pour savoir o\u00f9 aller. Laquelle devons-nous choisir pour aller \u00e0 coup s\u00fbr vers l'oasis ?","title":"Conclusion"},{"location":"1ere/seq1/logique/#exercices-les-expressions-booleennes","text":"","title":"Exercices : les expressions bool\u00e9ennes"},{"location":"1ere/seq1/logique/#exercice-0-amelioration-du-tp-sur-les-fonctions","text":"On dispose d'une fonction pair(n) , renvoyant si un entier n est pair ou non : def pair(n): return n%2 == 0 On consid\u00e8re une variable m repr\u00e9sentant un mois de l'ann\u00e9e. Quelle instruction \u00e9crire pour tester \"m est-t-il impair\" ? Ecrire le programme Python traduisant l'algorithme suivant : Si n est impair et qu il est un mois de la fin de l ann\u00e9e nb_jours vaut 30 Faire la m\u00eame chose avec l'algorithme suivant : Si n est pair et qu il est un mois du d\u00e9but de l ann\u00e9e nb_jours vaut 30 Comment combiner les conditions des questions 2 et 3 ? Compl\u00e9ter la fonction suivante, permettant de tester tous les mois de l'ann\u00e9e : def nombre_jours(m): if m == 2: nb = 28 elif ... nb = 30 ... return nb","title":"Exercice 0 (am\u00e9lioration du TP sur les fonctions) :"},{"location":"1ere/seq1/logique/#exercice-1-vrai-ou-faux","text":"Si a vaut True et b vaut False , not(a or b) s'\u00e9value \u00e0 True . L'expression not(a or b) a la m\u00eame valeur que l'expression (not a) or (not b) . Si a vaut True et b vaut True , not(a and b) s'\u00e9value \u00e0 True . L'expression not(a and b) a la m\u00eame valeur que l'expression not(a) or not(b) .","title":"Exercice 1 : Vrai ou Faux"},{"location":"1ere/seq1/logique/#exercice-2","text":"S\u00e9lectionner la(les) bonne(s) r\u00e9ponse(s) parmi les diff\u00e9rentes propositions. L'expression bool\u00e9enne a or not(b) s'\u00e9value \u00e0 True . Quelles peuvent \u00eatre les valeurs de a et de b ? a vaut True et b vaut True a vaut True et b vaut False a vaut False et b vaut True a vaut False et b vaut False Parmi les expressions suivantes, laquelle s'\u00e9value en True ? True and (False and True) True or (False and True) False and (False and True) False or (False and True)","title":"Exercice 2 :"},{"location":"1ere/seq1/logique/#exercice-3","text":"On consid\u00e8re l'expression a and b o\u00f9 a et b sont deux expressions bool\u00e9ennes. Si a vaut False , quelle sera la valeur de l'expression, en fonction de la valeur de b ? Que pouvez-vous en d\u00e9duire ? On consid\u00e8re l'expression a or b o\u00f9 a et b sont deux expressions bool\u00e9ennes. Si a vaut True , quelle sera la valeur de l'expression, en fonction de la valeur de b ? Que pouvez-vous en d\u00e9duire ? Conclusion (\u00e0 retenir) :","title":"Exercice 3 :"},{"location":"1ere/seq1/logique/#td-qui-faut-il-croire","text":"","title":"TD : Qui faut-il croire ?"},{"location":"1ere/seq1/logique/#a-un-village-perdu","text":"Vous voyagez dans un endroit que vous ne connaissez pas, et demandez votre chemin \u00e0 deux locaux que vous croisez. Vous souhaitez savoir o\u00f9 se trouve le village qui est votre objectif. Ils d\u00e9cident de jouer \u00e0 un jeu avec vous : ils vont vous donner des informations, et soit toutes ces informations seront vraies, soit elles seront toutes fausses. En appliquant la logique bool\u00e9enne, vous devez \u00eatre capable d'obtenir l'information que vous recherchez. Voici leurs propos : X : \"Le village se trouve dans la vall\u00e9e.\" Y : \"Non, il ne s\u2019y trouve pas.\" X : \"Ou alors dans les collines.\" On mod\u00e9lise le probl\u00e8me avec les variables suivantes : - V et C qui valent True si, respectivement, le village se trouve dans la vall\u00e9e ou dans les collines, et False sinon, - X et Y qui valent True si respectivement les affirmations de X et de Y sont vraies, et False sinon. Traduire X et Y en fonction de V , C , et des op\u00e9rateurs bool\u00e9ens qui conviennent. Compl\u00e9ter la table de v\u00e9rit\u00e9 suivante (on part du principe que le village ne peut \u00eatre que soit dans la vall\u00e9e, soit dans la colline) : V C X Y False True True False En d\u00e9duire o\u00f9 se trouve le village. \\pagebreak","title":"A. Un village perdu"},{"location":"1ere/seq1/logique/#b-au-tribunal","text":"Vous \u00eates dans le jury d'un tribunal et \u00e9coutez les t\u00e9moins d'une enqu\u00eate. On sait que chacun des t\u00e9moins soit toujours dit la v\u00e9rit\u00e9, soit ment toujours. Notre but est d'identifier ceux qui mentent et ceux qui ne mentent pas pour prononcer le verdict le plus juste possible. Les trois t\u00e9moins s'expriment : Ap : \"Personne ne doit croire C.\" Bp : \"A et C disent toujours la v\u00e9rit\u00e9.\" Cp : \"B dit la v\u00e9rit\u00e9.\" On mod\u00e9lise le probl\u00e8me avec les variables suivantes : A , B et C qui valent True si, respectivement, les t\u00e9moins A, B et C disent la v\u00e9rit\u00e9, et False sinon. Traduire Ap, Bp et Cp sous la forme d'expressions bool\u00e9ennes en utilisant les op\u00e9rateurs appropri\u00e9s. Compl\u00e9ter la table de v\u00e9rit\u00e9 suivante : A B C Ap Bp Cp False False False False False True False True False False True True True False False True False True True True False True True True Comment pouvez-vous en d\u00e9duire qui dit la v\u00e9rit\u00e9 et qui ment ?","title":"B. Au tribunal"},{"location":"1ere/seq2/entiers_positifs/","text":"body { text-align: justify} S\u00e9quence 2 I. Les entiers positifs Cours Le type de variables int pour \"integer\" de Python permet de manipuler des entiers. Ils sont ne sont en fait pas repr\u00e9sent\u00e9s comme nous en avons l'habitude : on utilise une autre base . A. La base 10 (d\u00e9cimale) La base 10 est celle que nous utilisons naturellement aujourd'hui. Elle est constitu\u00e9e de 10 chiffres, de 0 \u00e0 9, et chacun des chiffres utilis\u00e9 a une valeur diff\u00e9rente en fonction de sa position (on parle de num\u00e9ration de position ), nomm\u00e9e rang du chiffre. A chaque rang est associ\u00e9e une puissance de 10 diff\u00e9rente. Exemples : - Prenons le nombre \\(2005_{10}\\) (la notation \\(nombre_{10}\\) indique que l'on consid\u00e8re sa repr\u00e9sentation dans la base 10). Rang Chiffre 3 2 2 0 1 0 0 5 On peut d\u00e9composer ce nombre de la mani\u00e8re suivante : \\(2005_{10} =\\) Faire la m\u00eame chose avec le nombre \\(1990_{10}\\) . \\(1990_{10} =\\) Qu'a-t-on fait pour d\u00e9composer ces nombres dans la base 10 ? B. La base 2 (binaire) La base binaire est constitu\u00e9e de 2 nombres : 0 et 1 (un bit ), et est tr\u00e8s utilis\u00e9e en informatique. B.1. Du binaire au d\u00e9cimal Pour passer d'un nombre \u00e9crit en binaire \u00e0 sa repr\u00e9sentation en base d\u00e9cimale, on multiplie chaque chiffre par la puissance de 2 associ\u00e9e \u00e0 son rang (comme pour la base d\u00e9cimale, mais avec 2 au lieu de 10). Les puissances de 2 usuelles sont \u00e0 conna\u00eetre et/ou \u00e0 savoir retrouver : Puissance de 2 Valeur \\(2^0\\) \\(2^1\\) \\(2^2\\) \\(2^3\\) \\(2^4\\) \\(2^5\\) \\(2^6\\) \\(2^7\\) \\(2^8\\) \\(2^9\\) \\(2^10\\) Exemples : - \\(1010_2\\) . Rang Chiffre 3 2 1 0 \\(1010_2 =\\) Faire la m\u00eame chose avec le nombre \\(0110 0100_2\\) . \\(0110 0100_2 =\\) B.2. Du d\u00e9cimal au binaire Pour passer d'un nombre en \u00e9criture d\u00e9cimale \u00e0 sa repr\u00e9sentation en binaire, on utilise l' algorithme suivant : - On fait la division euclidienne ce nombre par 2 et on stocke le reste. - On remplace ce nombre par le quotient de sa division euclidienne par 2. - On s'arr\u00eate lorsque ce quotient devient 0. - Le nombre en repr\u00e9sentation binaire se lit en associant les restes des divisions successives, en commen\u00e7ant par la derni\u00e8re . Exemple : B.3. Nombre de bits n\u00e9cessaires Pour trouver le nombre de bits n\u00e9cessaires pour repr\u00e9senter un nombre d\u00e9cimal, on cherche la puissance de 2 sup\u00e9rieure la plus proche \u00e0 ce nombre. Le nombre de bits est donn\u00e9 par la puissance. C. La base 16 (hexad\u00e9cimale) La base 2 est \u00e0 la base du fonctionnement de l'informatique, mais son utilisation peut \u00eatre laborieuse lorsque l'on veut manipuler des nombres relativement grands. On utilise alors la base 16 , ou base hexad\u00e9cimale . La base hexad\u00e9cimale est une base de 16 symboles, utilisant l'ensemble des chiffres de 0 \u00e0 9 pour coder ses 10 premiers \u00e9l\u00e9ments, et ensuite les lettres de A \u00e0 F, repr\u00e9sentant les nombres \\(10_{10}\\) \u00e0 \\(15_{10}\\) . Base 10 Base 16 10 11 12 13 14 15 C.1. De l'hexad\u00e9cimal au d\u00e9cimal Pour passer d'un nombre \u00e9crit en hexad\u00e9cimal \u00e0 sa repr\u00e9sentation d\u00e9cimale, on multiplie chaque chiffre par la puissance de 16 associ\u00e9e \u00e0 son rang . Pour les lettres de A \u00e0 F, on utilise le nombre correspondant dans la base 10 (voir le tableau ci-dessus). Exemples : - \\(5_{16} =\\) - \\(2A_{16} =\\) - \\(1BF_{16} =\\) C.2. Du d\u00e9cimal \u00e0 l'hexad\u00e9cimal Pour passer d'un nombre en base 10 \u00e0 sa repr\u00e9sentation en base 16, on utilise le m\u00eame algorithme que pour passer de la base 10 \u00e0 la base 2, sauf que l'on divise successivement par 16. Exemple : C.3. Hexad\u00e9cimal et binaire Cette base est facile d'utilisation de par sa relation avec la base binaire : il est facile de passer de l'une \u00e0 l'autre. Pour repr\u00e9senter une valeur de 0 \u00e0 15, il faut 4 bits, donc pour repr\u00e9senter 1 octet on utilise 2 nombres en hexad\u00e9cimal. Pour passer de l' hexad\u00e9cimal au binaire , on associe la repr\u00e9sentation binaire de chacun de ses symboles. \\(2A_{16} =\\) Pour passer du binaire \u00e0 l'hexad\u00e9cimal , on regroupe les bits par 4 (on ajoute des \\(0\\) si n\u00e9cessaire) et on convertit chaque groupe dans sa repr\u00e9sentation hexad\u00e9cimale. \\(10001110_{2} =\\) Exemple : Pour repr\u00e9senter la couleur des pixels d'une image, on utilise des valeurs allant de 0 \u00e0 255 pour chacune des composantes rouge, vert et bleu. - Combien de bits faut-il pour repr\u00e9senter la valeur d'une composante ? - Pourquoi est-il int\u00e9ressant d'utiliser la base hexad\u00e9cimale ? D. Une base quelconque Les principes de conversion entre les bases d\u00e9cimale, binaire et hexad\u00e9cimale sont les m\u00eames pour les autres bases (base 5, 7, 18, ou pourquoi pas 666...). Chaque nombre est d\u00e9composable dans n'importe quelle base comme la somme des puissances de la base coefficient\u00e9es . TD : Repr\u00e9sentation des entiers positifs Exercice 1 : repr\u00e9sentation binaire des chiffres Calculer la repr\u00e9sentation binaire de l'ensemble des chiffres de \\(0_{10}\\) \u00e0 \\(9_{10}\\) . Exercice 2 : conversions binaire/d\u00e9cimal Convertir en d\u00e9cimal : \\(11_2\\) \\(101_2\\) \\(1010_2\\) \\(100111_2\\) Convertir en binaire, et v\u00e9rifier que le r\u00e9sultat est correct : \\(13_{10}\\) \\(18_{10}\\) \\(26_{10}\\) Exercice 3 : nombre de bits n\u00e9cessaires \u00e0 l'\u00e9criture d'un entier Calculer la repr\u00e9sentation d\u00e9cimale de l'entier repr\u00e9sent\u00e9 en binaire par \\(1111\\) . Calculer la repr\u00e9sentation d\u00e9cimale de l'entier repr\u00e9sent\u00e9 en binaire par \\(111111\\) . Quelle est la valeur maximale repr\u00e9sentable sur 4 bits ? Sur 6 bits ? (les exprimer avec des puissances de 2) Comment peut-on g\u00e9n\u00e9raliser pour \\(n\\) bits ? En d\u00e9duire combien de nombres sont repr\u00e9sentables sur \\(n\\) bits. Je consid\u00e8re le nombre \\(35_{10}\\) . Comment savoir combien de bits est-ce qu'il faut utiliser pour le repr\u00e9senter en binaire ? Exercice 4 : addition d'entiers positifs (attention \u00e0 l' overflow !) Pour faire la somme de nombres binaires, on utilise les r\u00e8gles suivantes : Somme binaire \\(0_2+0_2 = 0_2\\) \\(0_2+1_2 = 1_2\\) \\(1_2 + 1_2 = 0_2\\) et on retient \\(1\\) Faire la somme des entiers binaires \\(0100 1101_2\\) et \\(11000110_2\\) , et v\u00e9rifier votre r\u00e9sultat en utilisant la base d\u00e9cimale. En machine, si on utilise uniquement 1 octet pour repr\u00e9senter chaque entier, que se passerait-il lorsqu'on ferait l'addition de la question pr\u00e9c\u00e9dente ? En pratique, il faut v\u00e9rifier que l'on dispose de suffisamment de bits avant de faire l'addition de 2 entiers. Exprimer en fonction de \\(n\\) le nombre maximal de bits n\u00e9cessaires pour faire l'addition de deux entiers de taille \\(n\\) . Exercice 5 : multiplication d'entiers positifs Pour faire la multiplication de nombres binaires, on utilise les r\u00e8gles suivantes : Multiplication binaire \\(0_2*0_2 = 0_2\\) \\(0_2*1_2 = 0_2\\) \\(1_2 *1_2 = 1_2\\) On proc\u00e8de de la m\u00eame mani\u00e8re qu'avec le syst\u00e8me d\u00e9cimal. Par exemple, \\(1100_2*1010_2=11000+1100000=1111000_2\\) Poser la multiplication de \\(1010_2\\) par \\(1110_2\\) . Sur combien de bits s'\u00e9crivent les r\u00e9sultats de ces deux exemples ? G\u00e9n\u00e9raliser en fonction de \\(n\\) , combien de bits sont n\u00e9cessaire au maximum pour effectuer la multiplication de deux entiers positifs cod\u00e9s sur \\(n\\) bits. Exercice 6 : repr\u00e9sentation hexad\u00e9cimale Calculer la repr\u00e9sentation hexad\u00e9cimale de l'ensemble des nombres de \\(0_{10}\\) \u00e0 \\(20_{10}\\) . Exercice 7 : conversions hexad\u00e9cimal/d\u00e9cimal Convertir en d\u00e9cimal : \\(3_{16}\\) \\(1C_{16}\\) \\(2D_{16}\\) \\(B1_{16}\\) Convertir en hexad\u00e9cimal : \\(18_{10}\\) \\(75_{10}\\) \\(926_{10}\\) Exercice 8 : conversions hexad\u00e9cimal/binaire Convertir en hexad\u00e9cimal : \\(01000101_2\\) \\(11010000_2\\) Convertir en binaire : \\(16_{16}\\) \\(A5_{16}\\) Exercice 9 : adresses IP Le format d'une adresse IPv4 est le suivant : a.b.c.d avec a, b, c et d des entiers allant de 0 \u00e0 255. Combien de bits faut-il pour repr\u00e9senter chacun de ces entiers ? A combien d'octets cela correspond-il en tout ? Repr\u00e9senter l'adresse suivante en \u00e9criture binaire : 192.168.10.1 Une adresse IPv6 est constitu\u00e9e de 8 champs de 4 valeurs hexad\u00e9cimales, s\u00e9par\u00e9s par des \":\". Par exemple, celle du serveur de facebook.com est : 2a03:2880:f145:82:face:b00c:0:25de . Combien de bits faut-il pour repr\u00e9senter chaque champ ? Combien de bits faut-il en tout pour \u00e9crire une adresse au format IPv6 ? TP : Les entiers positifs en machine A. Les conversions en Python A.1. Vers le d\u00e9cimal Convertir \\(1001_2\\) en d\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console Python : >>> 0b1001 Convertir \\(5D_{16}\\) en d\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console python : >>> 0x5d A.2. Vers le binaire et l'hexad\u00e9cimal Les fonctions que vous allez utiliser sont des fonctions natives de Python, c'est-\u00e0-dire qu'il n'y a pas besoin d'importer de biblioth\u00e8ques pour les utiliser. 1. Convertir \\(11_{10}\\) en binaire. 2. V\u00e9rifier votre solution en tapant dans la console python : >>> bin(11) Quel est le format de la sortie de cette fonction ? Il est possible de la convertir en int avec la fonction int() dont un extrait de la documentation est donn\u00e9 ci-dessous. Utiliser cette documentation pour convertir la sortie de la fonction bin() en int . int(x, base=10) -> integer Convert a number or string to an integer (...) If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance (...) Convertir \\(195_{10}\\) en hexad\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console python : >>> hex(195) B. Le type int Dans certains langages informatiques, comme le C, il existe plusieurs types diff\u00e9rents d'entiers en fonction du nombre de bits n\u00e9cessaire pour repr\u00e9senter le nombre. En Python, il n'y a qu'un seul type. On peut donc penser que la taille des entiers qui peuvent \u00eatre manipul\u00e9s est infinie... mais l'infini n'existe pas en informatique. Si la taille maximale (souvent 32 ou 64 bits) utilisable par le processeur est d\u00e9pass\u00e9e, le nombre est d\u00e9coup\u00e9 en plusieurs parties. Cela a pour cons\u00e9quence un espace plus grand occup\u00e9 en m\u00e9moire et un ralentissement de l'ex\u00e9cution du programme. La biblioth\u00e8que time de Python permet de mesurer ce temps d'ex\u00e9cution. Dans le code suivant, on importe pour cela la fonction time : from time import time st = time() for i in range(50000): a = 2**i print(time()-st) range 0 \u00e0 49 999 50 000 \u00e0 99 999 200 000 \u00e0 249 999 temps d'ex\u00e9cution Ex\u00e9cuter ce programme et reporter dans le tableau la valeur qui s'affiche \u00e0 l'\u00e9cran. Changer les bornes du range pour avoir i variant de 50 000 \u00e0 99 999 . Reporter la valeur obtenue. Faire de m\u00eame pour faire varier i entre 200 000 et 249 999 et reporter le r\u00e9sultat. Qu'en concluez-vous ?","title":"I. Les entiers positifs"},{"location":"1ere/seq2/entiers_positifs/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"1ere/seq2/entiers_positifs/#i-les-entiers-positifs","text":"","title":"I. Les entiers positifs"},{"location":"1ere/seq2/entiers_positifs/#cours","text":"Le type de variables int pour \"integer\" de Python permet de manipuler des entiers. Ils sont ne sont en fait pas repr\u00e9sent\u00e9s comme nous en avons l'habitude : on utilise une autre base .","title":"Cours"},{"location":"1ere/seq2/entiers_positifs/#a-la-base-10-decimale","text":"La base 10 est celle que nous utilisons naturellement aujourd'hui. Elle est constitu\u00e9e de 10 chiffres, de 0 \u00e0 9, et chacun des chiffres utilis\u00e9 a une valeur diff\u00e9rente en fonction de sa position (on parle de num\u00e9ration de position ), nomm\u00e9e rang du chiffre. A chaque rang est associ\u00e9e une puissance de 10 diff\u00e9rente. Exemples : - Prenons le nombre \\(2005_{10}\\) (la notation \\(nombre_{10}\\) indique que l'on consid\u00e8re sa repr\u00e9sentation dans la base 10). Rang Chiffre 3 2 2 0 1 0 0 5 On peut d\u00e9composer ce nombre de la mani\u00e8re suivante : \\(2005_{10} =\\) Faire la m\u00eame chose avec le nombre \\(1990_{10}\\) . \\(1990_{10} =\\) Qu'a-t-on fait pour d\u00e9composer ces nombres dans la base 10 ?","title":"A. La base 10 (d\u00e9cimale)"},{"location":"1ere/seq2/entiers_positifs/#b-la-base-2-binaire","text":"La base binaire est constitu\u00e9e de 2 nombres : 0 et 1 (un bit ), et est tr\u00e8s utilis\u00e9e en informatique.","title":"B. La base 2 (binaire)"},{"location":"1ere/seq2/entiers_positifs/#b1-du-binaire-au-decimal","text":"Pour passer d'un nombre \u00e9crit en binaire \u00e0 sa repr\u00e9sentation en base d\u00e9cimale, on multiplie chaque chiffre par la puissance de 2 associ\u00e9e \u00e0 son rang (comme pour la base d\u00e9cimale, mais avec 2 au lieu de 10). Les puissances de 2 usuelles sont \u00e0 conna\u00eetre et/ou \u00e0 savoir retrouver : Puissance de 2 Valeur \\(2^0\\) \\(2^1\\) \\(2^2\\) \\(2^3\\) \\(2^4\\) \\(2^5\\) \\(2^6\\) \\(2^7\\) \\(2^8\\) \\(2^9\\) \\(2^10\\) Exemples : - \\(1010_2\\) . Rang Chiffre 3 2 1 0 \\(1010_2 =\\) Faire la m\u00eame chose avec le nombre \\(0110 0100_2\\) . \\(0110 0100_2 =\\)","title":"B.1. Du binaire au d\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#b2-du-decimal-au-binaire","text":"Pour passer d'un nombre en \u00e9criture d\u00e9cimale \u00e0 sa repr\u00e9sentation en binaire, on utilise l' algorithme suivant : - On fait la division euclidienne ce nombre par 2 et on stocke le reste. - On remplace ce nombre par le quotient de sa division euclidienne par 2. - On s'arr\u00eate lorsque ce quotient devient 0. - Le nombre en repr\u00e9sentation binaire se lit en associant les restes des divisions successives, en commen\u00e7ant par la derni\u00e8re . Exemple :","title":"B.2. Du d\u00e9cimal au binaire"},{"location":"1ere/seq2/entiers_positifs/#b3-nombre-de-bits-necessaires","text":"Pour trouver le nombre de bits n\u00e9cessaires pour repr\u00e9senter un nombre d\u00e9cimal, on cherche la puissance de 2 sup\u00e9rieure la plus proche \u00e0 ce nombre. Le nombre de bits est donn\u00e9 par la puissance.","title":"B.3. Nombre de bits n\u00e9cessaires"},{"location":"1ere/seq2/entiers_positifs/#c-la-base-16-hexadecimale","text":"La base 2 est \u00e0 la base du fonctionnement de l'informatique, mais son utilisation peut \u00eatre laborieuse lorsque l'on veut manipuler des nombres relativement grands. On utilise alors la base 16 , ou base hexad\u00e9cimale . La base hexad\u00e9cimale est une base de 16 symboles, utilisant l'ensemble des chiffres de 0 \u00e0 9 pour coder ses 10 premiers \u00e9l\u00e9ments, et ensuite les lettres de A \u00e0 F, repr\u00e9sentant les nombres \\(10_{10}\\) \u00e0 \\(15_{10}\\) . Base 10 Base 16 10 11 12 13 14 15","title":"C. La base 16 (hexad\u00e9cimale)"},{"location":"1ere/seq2/entiers_positifs/#c1-de-lhexadecimal-au-decimal","text":"Pour passer d'un nombre \u00e9crit en hexad\u00e9cimal \u00e0 sa repr\u00e9sentation d\u00e9cimale, on multiplie chaque chiffre par la puissance de 16 associ\u00e9e \u00e0 son rang . Pour les lettres de A \u00e0 F, on utilise le nombre correspondant dans la base 10 (voir le tableau ci-dessus). Exemples : - \\(5_{16} =\\) - \\(2A_{16} =\\) - \\(1BF_{16} =\\)","title":"C.1. De l'hexad\u00e9cimal au d\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#c2-du-decimal-a-lhexadecimal","text":"Pour passer d'un nombre en base 10 \u00e0 sa repr\u00e9sentation en base 16, on utilise le m\u00eame algorithme que pour passer de la base 10 \u00e0 la base 2, sauf que l'on divise successivement par 16. Exemple :","title":"C.2. Du d\u00e9cimal \u00e0 l'hexad\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#c3-hexadecimal-et-binaire","text":"Cette base est facile d'utilisation de par sa relation avec la base binaire : il est facile de passer de l'une \u00e0 l'autre. Pour repr\u00e9senter une valeur de 0 \u00e0 15, il faut 4 bits, donc pour repr\u00e9senter 1 octet on utilise 2 nombres en hexad\u00e9cimal. Pour passer de l' hexad\u00e9cimal au binaire , on associe la repr\u00e9sentation binaire de chacun de ses symboles. \\(2A_{16} =\\) Pour passer du binaire \u00e0 l'hexad\u00e9cimal , on regroupe les bits par 4 (on ajoute des \\(0\\) si n\u00e9cessaire) et on convertit chaque groupe dans sa repr\u00e9sentation hexad\u00e9cimale. \\(10001110_{2} =\\) Exemple : Pour repr\u00e9senter la couleur des pixels d'une image, on utilise des valeurs allant de 0 \u00e0 255 pour chacune des composantes rouge, vert et bleu. - Combien de bits faut-il pour repr\u00e9senter la valeur d'une composante ? - Pourquoi est-il int\u00e9ressant d'utiliser la base hexad\u00e9cimale ?","title":"C.3. Hexad\u00e9cimal et binaire"},{"location":"1ere/seq2/entiers_positifs/#d-une-base-quelconque","text":"Les principes de conversion entre les bases d\u00e9cimale, binaire et hexad\u00e9cimale sont les m\u00eames pour les autres bases (base 5, 7, 18, ou pourquoi pas 666...). Chaque nombre est d\u00e9composable dans n'importe quelle base comme la somme des puissances de la base coefficient\u00e9es .","title":"D. Une base quelconque"},{"location":"1ere/seq2/entiers_positifs/#td-representation-des-entiers-positifs","text":"","title":"TD : Repr\u00e9sentation des entiers positifs"},{"location":"1ere/seq2/entiers_positifs/#exercice-1-representation-binaire-des-chiffres","text":"Calculer la repr\u00e9sentation binaire de l'ensemble des chiffres de \\(0_{10}\\) \u00e0 \\(9_{10}\\) .","title":"Exercice 1 : repr\u00e9sentation binaire des chiffres"},{"location":"1ere/seq2/entiers_positifs/#exercice-2-conversions-binairedecimal","text":"Convertir en d\u00e9cimal : \\(11_2\\) \\(101_2\\) \\(1010_2\\) \\(100111_2\\) Convertir en binaire, et v\u00e9rifier que le r\u00e9sultat est correct : \\(13_{10}\\) \\(18_{10}\\) \\(26_{10}\\)","title":"Exercice 2 : conversions binaire/d\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#exercice-3-nombre-de-bits-necessaires-a-lecriture-dun-entier","text":"Calculer la repr\u00e9sentation d\u00e9cimale de l'entier repr\u00e9sent\u00e9 en binaire par \\(1111\\) . Calculer la repr\u00e9sentation d\u00e9cimale de l'entier repr\u00e9sent\u00e9 en binaire par \\(111111\\) . Quelle est la valeur maximale repr\u00e9sentable sur 4 bits ? Sur 6 bits ? (les exprimer avec des puissances de 2) Comment peut-on g\u00e9n\u00e9raliser pour \\(n\\) bits ? En d\u00e9duire combien de nombres sont repr\u00e9sentables sur \\(n\\) bits. Je consid\u00e8re le nombre \\(35_{10}\\) . Comment savoir combien de bits est-ce qu'il faut utiliser pour le repr\u00e9senter en binaire ?","title":"Exercice 3 : nombre de bits n\u00e9cessaires \u00e0 l'\u00e9criture d'un entier"},{"location":"1ere/seq2/entiers_positifs/#exercice-4-addition-dentiers-positifs-attention-a-loverflow","text":"Pour faire la somme de nombres binaires, on utilise les r\u00e8gles suivantes : Somme binaire \\(0_2+0_2 = 0_2\\) \\(0_2+1_2 = 1_2\\) \\(1_2 + 1_2 = 0_2\\) et on retient \\(1\\) Faire la somme des entiers binaires \\(0100 1101_2\\) et \\(11000110_2\\) , et v\u00e9rifier votre r\u00e9sultat en utilisant la base d\u00e9cimale. En machine, si on utilise uniquement 1 octet pour repr\u00e9senter chaque entier, que se passerait-il lorsqu'on ferait l'addition de la question pr\u00e9c\u00e9dente ? En pratique, il faut v\u00e9rifier que l'on dispose de suffisamment de bits avant de faire l'addition de 2 entiers. Exprimer en fonction de \\(n\\) le nombre maximal de bits n\u00e9cessaires pour faire l'addition de deux entiers de taille \\(n\\) .","title":"Exercice 4 : addition d'entiers positifs (attention \u00e0 l'overflow !)"},{"location":"1ere/seq2/entiers_positifs/#exercice-5-multiplication-dentiers-positifs","text":"Pour faire la multiplication de nombres binaires, on utilise les r\u00e8gles suivantes : Multiplication binaire \\(0_2*0_2 = 0_2\\) \\(0_2*1_2 = 0_2\\) \\(1_2 *1_2 = 1_2\\) On proc\u00e8de de la m\u00eame mani\u00e8re qu'avec le syst\u00e8me d\u00e9cimal. Par exemple, \\(1100_2*1010_2=11000+1100000=1111000_2\\) Poser la multiplication de \\(1010_2\\) par \\(1110_2\\) . Sur combien de bits s'\u00e9crivent les r\u00e9sultats de ces deux exemples ? G\u00e9n\u00e9raliser en fonction de \\(n\\) , combien de bits sont n\u00e9cessaire au maximum pour effectuer la multiplication de deux entiers positifs cod\u00e9s sur \\(n\\) bits.","title":"Exercice 5 : multiplication d'entiers positifs"},{"location":"1ere/seq2/entiers_positifs/#exercice-6-representation-hexadecimale","text":"Calculer la repr\u00e9sentation hexad\u00e9cimale de l'ensemble des nombres de \\(0_{10}\\) \u00e0 \\(20_{10}\\) .","title":"Exercice 6 : repr\u00e9sentation hexad\u00e9cimale"},{"location":"1ere/seq2/entiers_positifs/#exercice-7-conversions-hexadecimaldecimal","text":"Convertir en d\u00e9cimal : \\(3_{16}\\) \\(1C_{16}\\) \\(2D_{16}\\) \\(B1_{16}\\) Convertir en hexad\u00e9cimal : \\(18_{10}\\) \\(75_{10}\\) \\(926_{10}\\)","title":"Exercice 7 : conversions hexad\u00e9cimal/d\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#exercice-8-conversions-hexadecimalbinaire","text":"Convertir en hexad\u00e9cimal : \\(01000101_2\\) \\(11010000_2\\) Convertir en binaire : \\(16_{16}\\) \\(A5_{16}\\)","title":"Exercice 8 : conversions hexad\u00e9cimal/binaire"},{"location":"1ere/seq2/entiers_positifs/#exercice-9-adresses-ip","text":"Le format d'une adresse IPv4 est le suivant : a.b.c.d avec a, b, c et d des entiers allant de 0 \u00e0 255. Combien de bits faut-il pour repr\u00e9senter chacun de ces entiers ? A combien d'octets cela correspond-il en tout ? Repr\u00e9senter l'adresse suivante en \u00e9criture binaire : 192.168.10.1 Une adresse IPv6 est constitu\u00e9e de 8 champs de 4 valeurs hexad\u00e9cimales, s\u00e9par\u00e9s par des \":\". Par exemple, celle du serveur de facebook.com est : 2a03:2880:f145:82:face:b00c:0:25de . Combien de bits faut-il pour repr\u00e9senter chaque champ ? Combien de bits faut-il en tout pour \u00e9crire une adresse au format IPv6 ?","title":"Exercice 9 : adresses IP"},{"location":"1ere/seq2/entiers_positifs/#tp-les-entiers-positifs-en-machine","text":"","title":"TP : Les entiers positifs en machine"},{"location":"1ere/seq2/entiers_positifs/#a-les-conversions-en-python","text":"","title":"A. Les conversions en Python"},{"location":"1ere/seq2/entiers_positifs/#a1-vers-le-decimal","text":"Convertir \\(1001_2\\) en d\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console Python : >>> 0b1001 Convertir \\(5D_{16}\\) en d\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console python : >>> 0x5d","title":"A.1. Vers le d\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#a2-vers-le-binaire-et-lhexadecimal","text":"Les fonctions que vous allez utiliser sont des fonctions natives de Python, c'est-\u00e0-dire qu'il n'y a pas besoin d'importer de biblioth\u00e8ques pour les utiliser. 1. Convertir \\(11_{10}\\) en binaire. 2. V\u00e9rifier votre solution en tapant dans la console python : >>> bin(11) Quel est le format de la sortie de cette fonction ? Il est possible de la convertir en int avec la fonction int() dont un extrait de la documentation est donn\u00e9 ci-dessous. Utiliser cette documentation pour convertir la sortie de la fonction bin() en int . int(x, base=10) -> integer Convert a number or string to an integer (...) If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance (...) Convertir \\(195_{10}\\) en hexad\u00e9cimal. V\u00e9rifier votre solution en tapant dans la console python : >>> hex(195)","title":"A.2. Vers le binaire et l'hexad\u00e9cimal"},{"location":"1ere/seq2/entiers_positifs/#b-le-type-int","text":"Dans certains langages informatiques, comme le C, il existe plusieurs types diff\u00e9rents d'entiers en fonction du nombre de bits n\u00e9cessaire pour repr\u00e9senter le nombre. En Python, il n'y a qu'un seul type. On peut donc penser que la taille des entiers qui peuvent \u00eatre manipul\u00e9s est infinie... mais l'infini n'existe pas en informatique. Si la taille maximale (souvent 32 ou 64 bits) utilisable par le processeur est d\u00e9pass\u00e9e, le nombre est d\u00e9coup\u00e9 en plusieurs parties. Cela a pour cons\u00e9quence un espace plus grand occup\u00e9 en m\u00e9moire et un ralentissement de l'ex\u00e9cution du programme. La biblioth\u00e8que time de Python permet de mesurer ce temps d'ex\u00e9cution. Dans le code suivant, on importe pour cela la fonction time : from time import time st = time() for i in range(50000): a = 2**i print(time()-st) range 0 \u00e0 49 999 50 000 \u00e0 99 999 200 000 \u00e0 249 999 temps d'ex\u00e9cution Ex\u00e9cuter ce programme et reporter dans le tableau la valeur qui s'affiche \u00e0 l'\u00e9cran. Changer les bornes du range pour avoir i variant de 50 000 \u00e0 99 999 . Reporter la valeur obtenue. Faire de m\u00eame pour faire varier i entre 200 000 et 249 999 et reporter le r\u00e9sultat. Qu'en concluez-vous ?","title":"B. Le type int"},{"location":"1ere/seq2/entiers_relatifs/","text":"body { text-align: justify} S\u00e9quence 2 II. Les entiers relatifs TD A. Une premi\u00e8re approche... Pour repr\u00e9senter des entiers relatifs en machine, on peut tout d'abord penser qu'un bit peut \u00eatre r\u00e9serv\u00e9 au signe : par exemple le premier bit d'un entier cod\u00e9 sur 4 bits sera \u00e0 1 si c'est un entier n\u00e9gatif, \u00e0 0 si c'est un entier positif. \\(0010_2\\) repr\u00e9senterait alors \\(2_{10}\\) , et \\(1010_2\\) repr\u00e9senterait \\(-2_{10}\\) . Quels seraient les nombres minimal et maximal qui pourraient \u00eatre repr\u00e9sent\u00e9s ? Quel nombre aurait 2 repr\u00e9sentations ? Que ferait l'addition de \\(0101_2\\) ( \\(5_{10}\\) ) et \\(1011_2\\) ( \\(-3_{10}\\) ) ? B. Le compl\u00e9ment \u00e0 2 puissance n On propose de coder les entiers sur 4 bits avec la m\u00e9thode d\u00e9crite sur le sch\u00e9ma ci-contre. Les calculs suivants sont-ils corrects ? Compl\u00e9ter le calcul avec les r\u00e9sultats et les conversions (ne pas compter l'overflow pour l'addition binaire !) . Binaire D\u00e9cimal Binaire D\u00e9cimal \\(0101_2\\) \\(5_{10}\\) \\(0011_2\\) \\(+1101_2\\) \\(-3_{10}\\) \\(+1001_2\\) Ce codage ne sort pas de nulle part : il s'agit de ce que l'on appelle de la m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) . M\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) (compl\u00e9ment \u00e0 2) - Pour repr\u00e9senter un entier positif sur \\(n\\) bits, on prend sa repr\u00e9sentation binaire en ajoutant autant de 0 que n\u00e9cessaire devant pour avoir au total \\(n\\) bits. - Pour repr\u00e9senter un entier n\u00e9gatif \\(-m\\) sur \\(n\\) bits : On code en binaire l'entier positif \\(m\\) , On inverse tous les bits (on prend le compl\u00e9ment \u00e0 1 ), On additionne l'entier 1 au nombre obtenu. Si l'addition d\u00e9passe \\(n\\) bits, on ne conserve pas le bit suppl\u00e9mentaire ( \"overflow\" ). Exemple : Repr\u00e9senter -6 sur 4 bits. Entier 6 en binaire 0110 Compl\u00e9ment \u00e0 1 1001 Addition de 1 + 0001 Compl\u00e9ment \u00e0 \\(2^4\\) 1010 V\u00e9rifier avec le sch\u00e9ma \u00e0 quoi correspond la solution trouv\u00e9e. Utiliser la m\u00e9thode du compl\u00e9ment \u00e0 2 pour repr\u00e9senter : \\(-6_{10}\\) sur 8 bits, Entier 6 en binaire Compl\u00e9ment \u00e0 1 Addition de 1 Compl\u00e9ment \u00e0 \\(2^8\\) \\(-68_{10}\\) sur 8 bits. Entier 68 en binaire Compl\u00e9ment \u00e0 1 Addition de 1 Compl\u00e9ment \u00e0 \\(2^8\\) Faire l'addition de \\(-5_{10}\\) et \\(5_{10}\\) en binaire sur 4 bits (ne pas oublier de ne pas conserver l'\"overflow\") . Calculer le compl\u00e9ment \u00e0 \\(2^4\\) de \\(-5_{10}\\) . En d\u00e9duire comment obtenir la valeur d\u00e9cimale d'un entier n\u00e9gatif cod\u00e9 avec le compl\u00e9ment \u00e0 2. En d\u00e9duire la valeur d\u00e9cimale de l'entier repr\u00e9sent\u00e9 sur 4 bits par \\(1110_2\\) . Cours Plusieurs m\u00e9thodes existent pour repr\u00e9senter les entiers relatifs , dit aussi sign\u00e9s ( non-sign\u00e9s pour les entiers positifs). La m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) permet de faire des op\u00e9rations directement. A. La m\u00e9thode La m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) du TD est \u00e0 conna\u00eetre. Le nombre de bits utilis\u00e9s pour cette repr\u00e9sentation doit toujours \u00eatre pr\u00e9cis\u00e9 : 8, 16, 32, 64 bits sont des tailles couramment utilis\u00e9es. Le bit le plus \u00e0 gauche repr\u00e9sente le signe : il vaut 1 si l'entier est n\u00e9gatif, 0 s'il est positif . Par rapport aux entiers non-sign\u00e9s, il faut donc compter un bit suppl\u00e9mentaire pour le signe lorsque l'on \u00e9value le nombre de bits n\u00e9cessaire \u00e0 la repr\u00e9sentation du nombre. B. Les entiers repr\u00e9sentables Le nombre maximal repr\u00e9sentable sur 4 bits avec cette m\u00e9thode est \\(0111\\) . Quelle est sa valeur en d\u00e9cimal ? L'exprimer en fonction du nombre de bits utilis\u00e9 \\(n\\) . Sa valeur est de 7, soit \\(2^{n-1}-1\\) . De la m\u00eame mani\u00e8re, donner le nombre maximal repr\u00e9sentable sur 8 bits, en \u00e9criture binaire et d\u00e9cimale. Ce nombre est 01111111, soit 127. Le nombre minimal repr\u00e9sentable sur 4 bits est \\(1000\\) . Quelle est sa valeur en d\u00e9cimal ? L'exprimer en fonction de \\(n\\) . Ce nombre est -8, soit \\(2^{n-1}\\) . Conclusion : Les valeurs pouvant \u00eatre repr\u00e9sent\u00e9es avec cette m\u00e9thode vont donc de \\(-2^{n-1}\\) \u00e0 \\(2^{n-1}-1\\) .","title":"II. Les entiers relatifs"},{"location":"1ere/seq2/entiers_relatifs/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"1ere/seq2/entiers_relatifs/#ii-les-entiers-relatifs","text":"","title":"II. Les entiers relatifs"},{"location":"1ere/seq2/entiers_relatifs/#td","text":"","title":"TD"},{"location":"1ere/seq2/entiers_relatifs/#a-une-premiere-approche","text":"Pour repr\u00e9senter des entiers relatifs en machine, on peut tout d'abord penser qu'un bit peut \u00eatre r\u00e9serv\u00e9 au signe : par exemple le premier bit d'un entier cod\u00e9 sur 4 bits sera \u00e0 1 si c'est un entier n\u00e9gatif, \u00e0 0 si c'est un entier positif. \\(0010_2\\) repr\u00e9senterait alors \\(2_{10}\\) , et \\(1010_2\\) repr\u00e9senterait \\(-2_{10}\\) . Quels seraient les nombres minimal et maximal qui pourraient \u00eatre repr\u00e9sent\u00e9s ? Quel nombre aurait 2 repr\u00e9sentations ? Que ferait l'addition de \\(0101_2\\) ( \\(5_{10}\\) ) et \\(1011_2\\) ( \\(-3_{10}\\) ) ?","title":"A. Une premi\u00e8re approche..."},{"location":"1ere/seq2/entiers_relatifs/#b-le-complement-a-2-puissance-n","text":"On propose de coder les entiers sur 4 bits avec la m\u00e9thode d\u00e9crite sur le sch\u00e9ma ci-contre. Les calculs suivants sont-ils corrects ? Compl\u00e9ter le calcul avec les r\u00e9sultats et les conversions (ne pas compter l'overflow pour l'addition binaire !) . Binaire D\u00e9cimal Binaire D\u00e9cimal \\(0101_2\\) \\(5_{10}\\) \\(0011_2\\) \\(+1101_2\\) \\(-3_{10}\\) \\(+1001_2\\) Ce codage ne sort pas de nulle part : il s'agit de ce que l'on appelle de la m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) . M\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) (compl\u00e9ment \u00e0 2) - Pour repr\u00e9senter un entier positif sur \\(n\\) bits, on prend sa repr\u00e9sentation binaire en ajoutant autant de 0 que n\u00e9cessaire devant pour avoir au total \\(n\\) bits. - Pour repr\u00e9senter un entier n\u00e9gatif \\(-m\\) sur \\(n\\) bits : On code en binaire l'entier positif \\(m\\) , On inverse tous les bits (on prend le compl\u00e9ment \u00e0 1 ), On additionne l'entier 1 au nombre obtenu. Si l'addition d\u00e9passe \\(n\\) bits, on ne conserve pas le bit suppl\u00e9mentaire ( \"overflow\" ). Exemple : Repr\u00e9senter -6 sur 4 bits. Entier 6 en binaire 0110 Compl\u00e9ment \u00e0 1 1001 Addition de 1 + 0001 Compl\u00e9ment \u00e0 \\(2^4\\) 1010 V\u00e9rifier avec le sch\u00e9ma \u00e0 quoi correspond la solution trouv\u00e9e. Utiliser la m\u00e9thode du compl\u00e9ment \u00e0 2 pour repr\u00e9senter : \\(-6_{10}\\) sur 8 bits, Entier 6 en binaire Compl\u00e9ment \u00e0 1 Addition de 1 Compl\u00e9ment \u00e0 \\(2^8\\) \\(-68_{10}\\) sur 8 bits. Entier 68 en binaire Compl\u00e9ment \u00e0 1 Addition de 1 Compl\u00e9ment \u00e0 \\(2^8\\) Faire l'addition de \\(-5_{10}\\) et \\(5_{10}\\) en binaire sur 4 bits (ne pas oublier de ne pas conserver l'\"overflow\") . Calculer le compl\u00e9ment \u00e0 \\(2^4\\) de \\(-5_{10}\\) . En d\u00e9duire comment obtenir la valeur d\u00e9cimale d'un entier n\u00e9gatif cod\u00e9 avec le compl\u00e9ment \u00e0 2. En d\u00e9duire la valeur d\u00e9cimale de l'entier repr\u00e9sent\u00e9 sur 4 bits par \\(1110_2\\) .","title":"B. Le compl\u00e9ment \u00e0 2 puissance n"},{"location":"1ere/seq2/entiers_relatifs/#cours","text":"Plusieurs m\u00e9thodes existent pour repr\u00e9senter les entiers relatifs , dit aussi sign\u00e9s ( non-sign\u00e9s pour les entiers positifs). La m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) permet de faire des op\u00e9rations directement.","title":"Cours"},{"location":"1ere/seq2/entiers_relatifs/#a-la-methode","text":"La m\u00e9thode du compl\u00e9ment \u00e0 \\(2^n\\) du TD est \u00e0 conna\u00eetre. Le nombre de bits utilis\u00e9s pour cette repr\u00e9sentation doit toujours \u00eatre pr\u00e9cis\u00e9 : 8, 16, 32, 64 bits sont des tailles couramment utilis\u00e9es. Le bit le plus \u00e0 gauche repr\u00e9sente le signe : il vaut 1 si l'entier est n\u00e9gatif, 0 s'il est positif . Par rapport aux entiers non-sign\u00e9s, il faut donc compter un bit suppl\u00e9mentaire pour le signe lorsque l'on \u00e9value le nombre de bits n\u00e9cessaire \u00e0 la repr\u00e9sentation du nombre.","title":"A. La m\u00e9thode"},{"location":"1ere/seq2/entiers_relatifs/#b-les-entiers-representables","text":"Le nombre maximal repr\u00e9sentable sur 4 bits avec cette m\u00e9thode est \\(0111\\) . Quelle est sa valeur en d\u00e9cimal ? L'exprimer en fonction du nombre de bits utilis\u00e9 \\(n\\) . Sa valeur est de 7, soit \\(2^{n-1}-1\\) . De la m\u00eame mani\u00e8re, donner le nombre maximal repr\u00e9sentable sur 8 bits, en \u00e9criture binaire et d\u00e9cimale. Ce nombre est 01111111, soit 127. Le nombre minimal repr\u00e9sentable sur 4 bits est \\(1000\\) . Quelle est sa valeur en d\u00e9cimal ? L'exprimer en fonction de \\(n\\) . Ce nombre est -8, soit \\(2^{n-1}\\) . Conclusion : Les valeurs pouvant \u00eatre repr\u00e9sent\u00e9es avec cette m\u00e9thode vont donc de \\(-2^{n-1}\\) \u00e0 \\(2^{n-1}-1\\) .","title":"B. Les entiers repr\u00e9sentables"},{"location":"1ere/seq2/flottants/","text":"body { text-align: justify} S\u00e9quence 2 III. Les flottants Cours En informatique, les nombres r\u00e9els sont repr\u00e9sent\u00e9s par des flottants . Pourquoi ne pas utiliser le m\u00eame nom, comme pour les entiers ? Nous allons voir que ces deux ensembles ne sont pas tout \u00e0 fait \u00e9quivalents... Introduction Que doit, a priori, renvoyer le test 0.1 + 0.2 == 0.3 ? Il devrait renvoyer True . Que renvoie-t-il en fait ? Il renvoie False . Quelle est en fait la valeur de 0.1 + 0.2 ? Sa valeur est 3.0000...00004 Comprenons ce qu'il s'est pass\u00e9... A. D\u00e9composition et conversion de la base 2 \u00e0 la base 10 Prenons le nombre \\(3.375\\) . On sait \u00e9crire sa partie avant la virgule en binaire (qui vaut \\(11_2\\) ). Sa partie apr\u00e8s la virgule, on peut la d\u00e9composer dans la base 10, comme on l'a fait pour la partie enti\u00e8re : \\(0.375 = 3*10^{-1} + 7*10^{-2} + 5*10^{-3}\\) Les rangs des puissances de 10 sont ici n\u00e9gatifs (-1, -2 et -3). De la m\u00eame fa\u00e7on, un nombre \u00e0 virgule \u00e9crit en binaire se d\u00e9compose en fonction de 2 \u00e0 la puissance son rang : \\(10.011_2 = 1*2^1+1*2^{-2}+2^{-3} = 2+0.25+0.125 = 2.380\\) B. Conversion de la base 10 \u00e0 la base 2 Conversion de la partie d\u00e9cimale d'un nombre r\u00e9el de la base 10 \u00e0 la base 2 1. On multiplie cette partie par 2. 2. La partie enti\u00e8re de ce produit donne le premier coefficient apr\u00e8s la virgule. 2. On garde la partie d\u00e9cimale du produit. On r\u00e9it\u00e8re l'algorithme avec cette valeur, jusqu'\u00e0 ce qu'elle devienne nulle . Exemples : - Remplir le tableau suivant, pour obtenir la conversion de \\(0.375\\) . \\(3.375_{10} = 11.011_2\\) Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.375*2=0.750\\) \\(0\\) \\(0.750\\) \\(0.750*2=1.500\\) \\(1\\) \\(0.5\\) \\(0.5*2=1\\) \\(1\\) \\(0\\) Trouver la repr\u00e9sentation binaire de \\(0.25_{10}\\) . Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.25*2=0.5\\) \\(0\\) \\(0.5\\) \\(0.5*2=1\\) \\(1\\) \\(0\\) Que se passe-t-il lorsque l'on veut convertir la fraction \\(1/3\\) , qui a une \u00e9criture infinie en d\u00e9cimal ? L'algorithme ne se termine pas. Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(1/3*2=2/3\\) \\(0\\) \\(2/3\\) \\(2/3*2=4/3\\) \\(1\\) \\(1/3\\) Ecrire les 5 premi\u00e8res \u00e9tapes de la conversion de \\(0.1_{10}\\) . Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.1*2=0.2\\) \\(0\\) \\(0.2\\) \\(0.2*2=0.4\\) \\(0\\) \\(0.4\\) \\(0.4*2=0.8\\) \\(0\\) \\(0.8\\) \\(0.8*2=1.6\\) \\(1\\) \\(0.6\\) \\(0.6*2=1.2\\) \\(1\\) \\(0.2\\) Que se passe-t-il ? Que peut-on en d\u00e9duire sur la repr\u00e9sentation de \\(0.1_{10}\\) dans la machine ? Pourquoi le test 0.1 + 0.2 == 0.3 renvoie-t-il False ? L'algorithme ne s'arr\u00eate pas. 0.1 ne peut pas \u00eatre repr\u00e9sent\u00e9 de mani\u00e8re exacte, donc 0.1+0.2 ne fait pas exactement 0.3 avec la repr\u00e9sentation de la machine. D. La norme IEEE 754 (son d\u00e9tail n'est pas \u00e0 retenir) Le terme flottant vient du fait que l'on repr\u00e9sente ces nombres avec une virgule flottante . La norme IEEE 754 est la plus employ\u00e9e pour repr\u00e9senter ces nombres. On utilise soit 32 (version utilis\u00e9e ici pour l'exemple) , soit 64 bits pour stocker ces nombres. Le nombre est mis sous la forme : \\(signe*mantisse*base^{exposant}\\) , et on stocke : - son signe (1 bit) , - un exposant (8 bits) , - une mantisse (23 bits) . Exemple : \\(4,3125_{10}=100,0101_2\\) , qui doit \u00eatre transform\u00e9 pour correspondre \u00e0 cette norme, en \\(1,000101.2^2\\) . Il est stock\u00e9 sous la forme : \\(signe = 0\\) (nombre positif), \\(exposant = 10000001\\) (l'exposant est d\u00e9cal\u00e9), \\(mantisse = 0001010000000000000000\\) Conclusion En programmation, est-il pertinent de tester l'\u00e9galit\u00e9 entre deux flottants ? Comment peut-on faire alors ? Ce n'est pas pertinent, car on peut avoir des erreurs dues \u00e0 l'approximation de la repr\u00e9sentation, contrainte par un nombre de bits donn\u00e9s. On peut, \u00e0 la place, tester si ces nombres sont suffisamment proches.","title":"III. Les flottants"},{"location":"1ere/seq2/flottants/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"1ere/seq2/flottants/#iii-les-flottants","text":"","title":"III. Les flottants"},{"location":"1ere/seq2/flottants/#cours","text":"En informatique, les nombres r\u00e9els sont repr\u00e9sent\u00e9s par des flottants . Pourquoi ne pas utiliser le m\u00eame nom, comme pour les entiers ? Nous allons voir que ces deux ensembles ne sont pas tout \u00e0 fait \u00e9quivalents...","title":"Cours"},{"location":"1ere/seq2/flottants/#introduction","text":"Que doit, a priori, renvoyer le test 0.1 + 0.2 == 0.3 ? Il devrait renvoyer True . Que renvoie-t-il en fait ? Il renvoie False . Quelle est en fait la valeur de 0.1 + 0.2 ? Sa valeur est 3.0000...00004 Comprenons ce qu'il s'est pass\u00e9...","title":"Introduction"},{"location":"1ere/seq2/flottants/#a-decomposition-et-conversion-de-la-base-2-a-la-base-10","text":"Prenons le nombre \\(3.375\\) . On sait \u00e9crire sa partie avant la virgule en binaire (qui vaut \\(11_2\\) ). Sa partie apr\u00e8s la virgule, on peut la d\u00e9composer dans la base 10, comme on l'a fait pour la partie enti\u00e8re : \\(0.375 = 3*10^{-1} + 7*10^{-2} + 5*10^{-3}\\) Les rangs des puissances de 10 sont ici n\u00e9gatifs (-1, -2 et -3). De la m\u00eame fa\u00e7on, un nombre \u00e0 virgule \u00e9crit en binaire se d\u00e9compose en fonction de 2 \u00e0 la puissance son rang : \\(10.011_2 = 1*2^1+1*2^{-2}+2^{-3} = 2+0.25+0.125 = 2.380\\)","title":"A. D\u00e9composition et conversion de la base 2 \u00e0 la base 10"},{"location":"1ere/seq2/flottants/#b-conversion-de-la-base-10-a-la-base-2","text":"Conversion de la partie d\u00e9cimale d'un nombre r\u00e9el de la base 10 \u00e0 la base 2 1. On multiplie cette partie par 2. 2. La partie enti\u00e8re de ce produit donne le premier coefficient apr\u00e8s la virgule. 2. On garde la partie d\u00e9cimale du produit. On r\u00e9it\u00e8re l'algorithme avec cette valeur, jusqu'\u00e0 ce qu'elle devienne nulle . Exemples : - Remplir le tableau suivant, pour obtenir la conversion de \\(0.375\\) . \\(3.375_{10} = 11.011_2\\) Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.375*2=0.750\\) \\(0\\) \\(0.750\\) \\(0.750*2=1.500\\) \\(1\\) \\(0.5\\) \\(0.5*2=1\\) \\(1\\) \\(0\\) Trouver la repr\u00e9sentation binaire de \\(0.25_{10}\\) . Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.25*2=0.5\\) \\(0\\) \\(0.5\\) \\(0.5*2=1\\) \\(1\\) \\(0\\) Que se passe-t-il lorsque l'on veut convertir la fraction \\(1/3\\) , qui a une \u00e9criture infinie en d\u00e9cimal ? L'algorithme ne se termine pas. Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(1/3*2=2/3\\) \\(0\\) \\(2/3\\) \\(2/3*2=4/3\\) \\(1\\) \\(1/3\\) Ecrire les 5 premi\u00e8res \u00e9tapes de la conversion de \\(0.1_{10}\\) . Multiplication par 2 de la partie d\u00e9cimale Partie enti\u00e8re du produit Partie d\u00e9cimale du produit \\(0.1*2=0.2\\) \\(0\\) \\(0.2\\) \\(0.2*2=0.4\\) \\(0\\) \\(0.4\\) \\(0.4*2=0.8\\) \\(0\\) \\(0.8\\) \\(0.8*2=1.6\\) \\(1\\) \\(0.6\\) \\(0.6*2=1.2\\) \\(1\\) \\(0.2\\) Que se passe-t-il ? Que peut-on en d\u00e9duire sur la repr\u00e9sentation de \\(0.1_{10}\\) dans la machine ? Pourquoi le test 0.1 + 0.2 == 0.3 renvoie-t-il False ? L'algorithme ne s'arr\u00eate pas. 0.1 ne peut pas \u00eatre repr\u00e9sent\u00e9 de mani\u00e8re exacte, donc 0.1+0.2 ne fait pas exactement 0.3 avec la repr\u00e9sentation de la machine.","title":"B. Conversion de la base 10 \u00e0 la base 2"},{"location":"1ere/seq2/flottants/#d-la-norme-ieee-754-son-detail-nest-pas-a-retenir","text":"Le terme flottant vient du fait que l'on repr\u00e9sente ces nombres avec une virgule flottante . La norme IEEE 754 est la plus employ\u00e9e pour repr\u00e9senter ces nombres. On utilise soit 32 (version utilis\u00e9e ici pour l'exemple) , soit 64 bits pour stocker ces nombres. Le nombre est mis sous la forme : \\(signe*mantisse*base^{exposant}\\) , et on stocke : - son signe (1 bit) , - un exposant (8 bits) , - une mantisse (23 bits) . Exemple : \\(4,3125_{10}=100,0101_2\\) , qui doit \u00eatre transform\u00e9 pour correspondre \u00e0 cette norme, en \\(1,000101.2^2\\) . Il est stock\u00e9 sous la forme : \\(signe = 0\\) (nombre positif), \\(exposant = 10000001\\) (l'exposant est d\u00e9cal\u00e9), \\(mantisse = 0001010000000000000000\\)","title":"D. La norme IEEE 754 (son d\u00e9tail n'est pas \u00e0 retenir)"},{"location":"1ere/seq2/flottants/#conclusion","text":"En programmation, est-il pertinent de tester l'\u00e9galit\u00e9 entre deux flottants ? Comment peut-on faire alors ? Ce n'est pas pertinent, car on peut avoir des erreurs dues \u00e0 l'approximation de la repr\u00e9sentation, contrainte par un nombre de bits donn\u00e9s. On peut, \u00e0 la place, tester si ces nombres sont suffisamment proches.","title":"Conclusion"},{"location":"projets/1ere_cyber/presentation/","text":"body { text-align: justify} Projet Cybers\u00e9curit\u00e9","title":"1\u00e8re - Cybers\u00e9curit\u00e9"},{"location":"projets/1ere_cyber/presentation/#projet-cybersecurite","text":"","title":"Projet Cybers\u00e9curit\u00e9"},{"location":"projets/tle_poo_rec/presentation/","text":"body { text-align: justify} Projet POO & R\u00e9cursivit\u00e9","title":"Tle - POO & R\u00e9cursivit\u00e9"},{"location":"projets/tle_poo_rec/presentation/#projet-poo-recursivite","text":"","title":"Projet POO &amp; R\u00e9cursivit\u00e9"},{"location":"projets/tle_poo_rec/presentation/#_1","text":"","title":""},{"location":"tle/seq1/","text":"S\u00e9quence 1 : Paradigmes & Programmation Orient\u00e9e Objet Paradigmes imp\u00e9ratif et fonctionnel Paradigme objet Synth\u00e8se","title":"S\u00e9quence 1 : Paradigmes & Programmation Orient\u00e9e Objet"},{"location":"tle/seq1/#sequence-1-paradigmes-programmation-orientee-objet","text":"Paradigmes imp\u00e9ratif et fonctionnel Paradigme objet Synth\u00e8se","title":"S\u00e9quence 1 : Paradigmes &amp; Programmation Orient\u00e9e Objet"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/","text":"body { text-align: justify} S\u00e9quence 1 I. Les paradigmes imp\u00e9ratif et fonctionnel Cours A. Les \u00e9l\u00e9ments de base de la programmation l = [2, 6, 9] s = 0 if l[0]%2 == 0: s = s + l[0] if l[1]%2 == 0: s = s + l[1] if l[2]%2 == 0: s = s + l[2] Dans l'exemple ci-dessus, quels sont les \u00e9l\u00e9ments de base de la programmation utilis\u00e9s ? On identifie des affectations, des instructions conditionnelles. L'ensemble est une s\u00e9quence d'instructions. Que fait ce programme ? Il calcule la somme des \u00e9l\u00e9ments pairs d'une liste Python. Proposer une autre mani\u00e8re d'\u00e9crire ce programme. Quel autre \u00e9l\u00e9ment de programmation est-il pertinent d'utiliser ici ? Il est pertinent d'utiliser une boucle born\u00e9e. Ecrire ce programme en utilisant deux fonctions interm\u00e9diaires. Il y a donc plusieurs mani\u00e8re de programmer un m\u00eame algorithme, en utilisant diff\u00e9remment les \u00e9l\u00e9ments de programmation \u00e0 notre disposition. Un paradigme de programmation est une mani\u00e8re de programmer sp\u00e9cifique. B. Le paradigme imp\u00e9ratif Le paradigme imp\u00e9ratif est le paradigme le plus courant, utilis\u00e9 par de nombreux langages de programmation comme Python (qui int\u00e8gre aussi d'autres paradigmes !) . Il consiste \u00e0 d\u00e9crire un programme sous la forme de s\u00e9quences d'instructions \u00e0 effectuer dans un ordre pr\u00e9cis. Les caract\u00e9ristiques de ce paradigme sont : - importance de l'ordre des instructions, - utilisation d'affectations de variables, d'expressions conditionnelles et de boucles. Cette mani\u00e8re de programmer est proche du fonctionnement de la machine et peut sembler la plus intuitive. Pourquoi utiliser d'autres paradigmes ? On peut pr\u00e9f\u00e9rer d'autres mani\u00e8res de programmer en fonction du champ d'application du programme, du probl\u00e8me sp\u00e9cifique qui est trait\u00e9, ou tout simplement des go\u00fbts du programmeur. C. Le paradigme fonctionnel Le paradigme fonctionnel est un paradigme rigoureux, permettant de plus facilement tester, d\u00e9boguer et optimiser les programmes. C.1. Les fonctions Rappeler la syntaxe de d\u00e9finition et d'appel d'une fonction en Python : def nom_de_la_fonction(entree1,entree2): #s\u00e9quence d'instructions (return sortie) resultat = nom_de_la_fonction(val1, val2) Le paradigme fonctionnel est centr\u00e9, comme son nom l'indique, sur l'utilisation de fonctions. Plus pr\u00e9cis\u00e9ment, on utilise des fonctions dites \"pures\" : des fonctions qui, \u00e9tant donn\u00e9 des param\u00e8tres d'entr\u00e9e, renvoient toujours la m\u00eame sortie. Pour cela, il ne faut pas qu'elles cr\u00e9ent d' effets de bord . C.2. Les effets de bord Un effet de bord correspond \u00e0 la modification par une fonction d'une ou plusieurs variable(s) d\u00e9finie(s) en dehors de cette fonction. Une variable d\u00e9finie en dehors d'une fonction est une variable globale , utilisable dans tout le programme. Une variable d\u00e9finie dans une fonction est par d\u00e9faut locale : elle n'existe que dans cette fonction. Exemple : l = [0,1,2,3] def remplace(x): y = l[0] l[0] = x return y Que fait cette fonction ? En \u00e9crire la sp\u00e9cification (description des entr\u00e9es et sorties). Cette fonction remplace la valeur du premier \u00e9lement de l par une valeur donn\u00e9e en entr\u00e9e. Entr\u00e9e : entier x rempla\u00e7ant la valeur du premier \u00e9l\u00e9ment de l Sortie : l'entier y en premi\u00e8re position de la liste l avant d'\u00eatre remplac\u00e9 Que renvoie l'appel de remplace(1) ? Un deuxi\u00e8me appel de remplace(1) ? Le premier appel renvoie 0 , alors que le deuxi\u00e8me renvoie 1 . Que peut-on en conclure ? Il y a modification d'une variable d\u00e9finie en dehors de remplace : elle cr\u00e9e un effet de bord. La fonction, appel\u00e9e plusieurs fois avec le m\u00eame param\u00e8tre ne renvoie pas la m\u00eame valeur : ce n'est pas une fonction pure. Proposer une fonction \"pure\" effectuant le m\u00eame traitement que remplace . def remplace(x, l): y = l[0] l[0] = x return y N.B. : une fonction pure renvoie toujours une valeur (sinon, vu qu'elle n'a pas d'effet de bord, elle ne servirait pas \u00e0 grand chose...). C.3. Les caract\u00e9ristiques du paradigme fonctionnel utilisation de fonctions imbriqu\u00e9es (cf partie A), utilisation de fonctions pures (donc pas d'effet de bord !), on \u00e9vite l'affectation de valeurs \u00e0 des variables (utilisation de fonctions \u00e0 la place). Ces caract\u00e9ristiques rendent les programmes plus fiables : diff\u00e9rentes bonnes pratiques de programmation s'inspirent de cette mani\u00e8re de programmer. Exercices Exercice 1 : (sur feuille) Dans les exemples suivant, indiquer : - s'il y a un effet de bord ou non, - si la fonction est pure, - s'il y a un effet de bord, proposer une autre version de la fonction qui l'\u00e9limine. 1. i = 5 def f(): return i>5 2. def ajout(i,l): tab = l + [i] return tab 3. x = 11 l = [1,3,5,7,9] def ajoute(): if x>l[-1]: l.append(x) return l Exercice 2 : (sur feuille) Identifier les caract\u00e9ristiques se rapportant au paradigme imp\u00e9ratif, et celles se rapportant au paradigme fonctionnel. - autorise les effets de bord, - l'ordre des instructions n'a pas toujours d'importance, - utilise des affectations de variables, - utilise des boucles, - d\u00e9coupe un programme en fonctions. Exercice 3 : (sur ordinateur) Les codes suivant correspondent \u00e0 des algorithmes vus en premi\u00e8re. - Ecrire chacun sous la forme d'une fonction, dont on aura identifi\u00e9 les param\u00e8tres d'entr\u00e9e et de sortie et dont on choisira le nom de mani\u00e8re ad\u00e9quate. On veut des fonctions pures, n'utilisant pas de variables globales. - Renommer les variables pour que l'on comprenne plus facilement leur r\u00f4le. - Ajouter les sp\u00e9cifications des entr\u00e9es et des sorties. 1. x = 0 y = 0 l = [6,8,7,1,0] for i in range(len(l)): if l[i]>x: x = l[i] y = i print(x, y) 2. o = 0 t = [6,2,4,8,2,1,3] for e in t: if e == 2: o = o+1 print(o)","title":"I. Paradigme imp\u00e9ratif et fonctionnel"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#sequence-1","text":"","title":"S\u00e9quence 1"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#i-les-paradigmes-imperatif-et-fonctionnel","text":"","title":"I. Les paradigmes imp\u00e9ratif et fonctionnel"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#cours","text":"","title":"Cours"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#a-les-elements-de-base-de-la-programmation","text":"l = [2, 6, 9] s = 0 if l[0]%2 == 0: s = s + l[0] if l[1]%2 == 0: s = s + l[1] if l[2]%2 == 0: s = s + l[2] Dans l'exemple ci-dessus, quels sont les \u00e9l\u00e9ments de base de la programmation utilis\u00e9s ? On identifie des affectations, des instructions conditionnelles. L'ensemble est une s\u00e9quence d'instructions. Que fait ce programme ? Il calcule la somme des \u00e9l\u00e9ments pairs d'une liste Python. Proposer une autre mani\u00e8re d'\u00e9crire ce programme. Quel autre \u00e9l\u00e9ment de programmation est-il pertinent d'utiliser ici ? Il est pertinent d'utiliser une boucle born\u00e9e. Ecrire ce programme en utilisant deux fonctions interm\u00e9diaires. Il y a donc plusieurs mani\u00e8re de programmer un m\u00eame algorithme, en utilisant diff\u00e9remment les \u00e9l\u00e9ments de programmation \u00e0 notre disposition. Un paradigme de programmation est une mani\u00e8re de programmer sp\u00e9cifique.","title":"A. Les \u00e9l\u00e9ments de base de la programmation"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#b-le-paradigme-imperatif","text":"Le paradigme imp\u00e9ratif est le paradigme le plus courant, utilis\u00e9 par de nombreux langages de programmation comme Python (qui int\u00e8gre aussi d'autres paradigmes !) . Il consiste \u00e0 d\u00e9crire un programme sous la forme de s\u00e9quences d'instructions \u00e0 effectuer dans un ordre pr\u00e9cis. Les caract\u00e9ristiques de ce paradigme sont : - importance de l'ordre des instructions, - utilisation d'affectations de variables, d'expressions conditionnelles et de boucles. Cette mani\u00e8re de programmer est proche du fonctionnement de la machine et peut sembler la plus intuitive. Pourquoi utiliser d'autres paradigmes ? On peut pr\u00e9f\u00e9rer d'autres mani\u00e8res de programmer en fonction du champ d'application du programme, du probl\u00e8me sp\u00e9cifique qui est trait\u00e9, ou tout simplement des go\u00fbts du programmeur.","title":"B. Le paradigme imp\u00e9ratif"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#c-le-paradigme-fonctionnel","text":"Le paradigme fonctionnel est un paradigme rigoureux, permettant de plus facilement tester, d\u00e9boguer et optimiser les programmes.","title":"C. Le paradigme fonctionnel"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#c1-les-fonctions","text":"Rappeler la syntaxe de d\u00e9finition et d'appel d'une fonction en Python : def nom_de_la_fonction(entree1,entree2): #s\u00e9quence d'instructions (return sortie) resultat = nom_de_la_fonction(val1, val2) Le paradigme fonctionnel est centr\u00e9, comme son nom l'indique, sur l'utilisation de fonctions. Plus pr\u00e9cis\u00e9ment, on utilise des fonctions dites \"pures\" : des fonctions qui, \u00e9tant donn\u00e9 des param\u00e8tres d'entr\u00e9e, renvoient toujours la m\u00eame sortie. Pour cela, il ne faut pas qu'elles cr\u00e9ent d' effets de bord .","title":"C.1. Les fonctions"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#c2-les-effets-de-bord","text":"Un effet de bord correspond \u00e0 la modification par une fonction d'une ou plusieurs variable(s) d\u00e9finie(s) en dehors de cette fonction. Une variable d\u00e9finie en dehors d'une fonction est une variable globale , utilisable dans tout le programme. Une variable d\u00e9finie dans une fonction est par d\u00e9faut locale : elle n'existe que dans cette fonction. Exemple : l = [0,1,2,3] def remplace(x): y = l[0] l[0] = x return y Que fait cette fonction ? En \u00e9crire la sp\u00e9cification (description des entr\u00e9es et sorties). Cette fonction remplace la valeur du premier \u00e9lement de l par une valeur donn\u00e9e en entr\u00e9e. Entr\u00e9e : entier x rempla\u00e7ant la valeur du premier \u00e9l\u00e9ment de l Sortie : l'entier y en premi\u00e8re position de la liste l avant d'\u00eatre remplac\u00e9 Que renvoie l'appel de remplace(1) ? Un deuxi\u00e8me appel de remplace(1) ? Le premier appel renvoie 0 , alors que le deuxi\u00e8me renvoie 1 . Que peut-on en conclure ? Il y a modification d'une variable d\u00e9finie en dehors de remplace : elle cr\u00e9e un effet de bord. La fonction, appel\u00e9e plusieurs fois avec le m\u00eame param\u00e8tre ne renvoie pas la m\u00eame valeur : ce n'est pas une fonction pure. Proposer une fonction \"pure\" effectuant le m\u00eame traitement que remplace . def remplace(x, l): y = l[0] l[0] = x return y N.B. : une fonction pure renvoie toujours une valeur (sinon, vu qu'elle n'a pas d'effet de bord, elle ne servirait pas \u00e0 grand chose...).","title":"C.2. Les effets de bord"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#c3-les-caracteristiques-du-paradigme-fonctionnel","text":"utilisation de fonctions imbriqu\u00e9es (cf partie A), utilisation de fonctions pures (donc pas d'effet de bord !), on \u00e9vite l'affectation de valeurs \u00e0 des variables (utilisation de fonctions \u00e0 la place). Ces caract\u00e9ristiques rendent les programmes plus fiables : diff\u00e9rentes bonnes pratiques de programmation s'inspirent de cette mani\u00e8re de programmer.","title":"C.3. Les caract\u00e9ristiques du paradigme fonctionnel"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#exercices","text":"","title":"Exercices"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#exercice-1-sur-feuille","text":"Dans les exemples suivant, indiquer : - s'il y a un effet de bord ou non, - si la fonction est pure, - s'il y a un effet de bord, proposer une autre version de la fonction qui l'\u00e9limine. 1. i = 5 def f(): return i>5 2. def ajout(i,l): tab = l + [i] return tab 3. x = 11 l = [1,3,5,7,9] def ajoute(): if x>l[-1]: l.append(x) return l","title":"Exercice 1 : (sur feuille)"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#exercice-2-sur-feuille","text":"Identifier les caract\u00e9ristiques se rapportant au paradigme imp\u00e9ratif, et celles se rapportant au paradigme fonctionnel. - autorise les effets de bord, - l'ordre des instructions n'a pas toujours d'importance, - utilise des affectations de variables, - utilise des boucles, - d\u00e9coupe un programme en fonctions.","title":"Exercice 2 : (sur feuille)"},{"location":"tle/seq1/Imp%C3%A9ratif_Fonctionnel/#exercice-3-sur-ordinateur","text":"Les codes suivant correspondent \u00e0 des algorithmes vus en premi\u00e8re. - Ecrire chacun sous la forme d'une fonction, dont on aura identifi\u00e9 les param\u00e8tres d'entr\u00e9e et de sortie et dont on choisira le nom de mani\u00e8re ad\u00e9quate. On veut des fonctions pures, n'utilisant pas de variables globales. - Renommer les variables pour que l'on comprenne plus facilement leur r\u00f4le. - Ajouter les sp\u00e9cifications des entr\u00e9es et des sorties. 1. x = 0 y = 0 l = [6,8,7,1,0] for i in range(len(l)): if l[i]>x: x = l[i] y = i print(x, y) 2. o = 0 t = [6,2,4,8,2,1,3] for e in t: if e == 2: o = o+1 print(o)","title":"Exercice 3 : (sur ordinateur)"},{"location":"tle/seq1/POO/","text":"body { text-align: justify} S\u00e9quence 1 II. Le paradigme orient\u00e9 objet TP : Un combat de monstres Dans ce TP, vous utiliserez un seul fichier Python que vous modifierez au fur et \u00e0 mesure. Enregistrez-le au d\u00e9but du TP. Dans l'univers de la s\u00e9rie du Sorceleur de l'\u00e9crivain Andrzej Sapkowski, diff\u00e9rents types de personnages s'affrontent. Certains ont des caract\u00e9ristiques particuli\u00e8res comme les sorceleurs qui sont tr\u00e8s habiles au combat et ma\u00eetrisent une certaine forme de magie. Il sont charg\u00e9s d'\u00e9liminer les monstres pr\u00e9sents sur le continent. Pour repr\u00e9senter une situation de mani\u00e8re r\u00e9aliste, le paradigme dit \"objet\" est le plus appropri\u00e9. Il permet de mod\u00e9liser des \u00e9l\u00e9ments du monde r\u00e9el ou bien des concepts. Ce paradigme utilise des classes, une classe pouvant d\u00e9finir aussi bien un animal, qu'un v\u00e9hicule, un humain, un steak, un schtroumpf... Les \u00e9l\u00e9ments de ces classes sont des objets , que nous allons utiliser pour repr\u00e9senter des sorceleurs et des monstres. Impl\u00e9menter le code suivant : class Personnage: # d\u00e9finition de la classe pass # pour l'instant, elle ne fait rien geralt = Personnage() # cr\u00e9ation d'un \u00e9l\u00e9ment de la classe : un objet monstre = Personnage() # cr\u00e9ation d'un deuxi\u00e8me objet Tous les objets de la classe Sorceleur auront les m\u00eames caract\u00e9ristiques : des variables nomm\u00e9es attributs , et les m\u00eames comportements d\u00e9finis par des fonctions appel\u00e9es m\u00e9thodes . Parmi les caract\u00e9ristiques des sorceleurs, on peut avoir leur nombre de points de vie. Impl\u00e9menter le code suivant : class Personnage: def __init__(self): # cette fonction est une m\u00e9thode de la classe Sorceleur nomm\u00e9e \"constructeur\" : utilis\u00e9e pour \"construire\" chaque nouvel objet self.vie = 50 # on attribue 50 points de vie par d\u00e9faut \u00e0 tout nouveau sorceleur geralt = Personnage() monstre = Personnage() Taper dans la console : geralt.vie et monstre.vie et v\u00e9rifier que la valeur attribu\u00e9e \u00e0 l'attribue vie est correcte. On peut vouloir d\u00e9finir au moment de la cr\u00e9ation de chaque objet une valeur initiale de points de vie diff\u00e9rente pour chacun. Modifions le programme : class Personnage: def __init__(self, v): # la valeur est donn\u00e9e en param\u00e8tre du constructeur self.vie = v geralt = Personnage() monstre = Personnage() V\u00e9rifier que le nombre de points de vie de chacun est correct. Un constructeur peut avoir plusieurs arguments, mais il a toujours au moins l'argument self qui fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame. self est n\u00e9cessaire pour acc\u00e9der aux attributs et aux m\u00e9thodes \u00e0 l'int\u00e9rieur de la classe. Il n'existe plus \u00e0 l'ext\u00e9rieur. Ajoutons quelques m\u00e9thodes \u00e0 notre classe pour mieux simuler le comportement des personnages : class Personnage: def __init__(self, v): self.vie = v def perd_vie(self): self.vie = self.vie - 1 def donne_etat(self): return self.vie geralt = Personnage(50) geralt.perd_vie() pts = geralt.donne_etat() Que vaut la variable pts ? Modifier la m\u00e9thode perd_vie pour que le nombre de points perdus soit d\u00e9fini al\u00e9atoirement \u00e0 l'aide de la fonction randint de la biblioth\u00e8que du random : elle retournera un entier entre 1 et 10 qui correspondra au nombre de points perdus. from random import randint # instruction pour importer la fonction help(randint) \"commande pour extraire la documentation de la fonction\" Ajouter un attribut exp repr\u00e9sentant l'exp\u00e9rience du personnage. Cr\u00e9er les m\u00e9thodes gagne_exp et donne_exp permettant, respectivement, de faire gagner une valeur e d'exp\u00e9rience, et de consulter la valeur de l'attribut exp . Cr\u00e9er un programme principal dans lequel geralt affronte monstre selon les r\u00e8gles suivantes : Chacun attaque l'autre \u00e0 tour de r\u00f4le jusqu'\u00e0 ce que le nombre de points de vie d'un des personnages descende \u00e0 0 (ou moins), Si l' exp\u00e9rience d'un personnage est sup\u00e9rieure \u00e0 40, alors son adversaire perd entre 5 et 10 points \u00e0 chaque attaque. Sinon, il perd entre 0 et 5 points. Le vainqueur il gagne 2 points d'exp\u00e9rience. Il peut ensuite combattre un autre adversaire. Attention ! Pour acc\u00e9der aux valeurs des attributs, il faut utiliser les m\u00e9thodes donne_etat et donne_exp . Pour aller plus loin... Vous pouvez \u00e9tendre les possibilit\u00e9s du jeu, par exemple en organisant une sorte de tournoi avec plusieurs sorceleurs et plusieurs monstres. Il est aussi possible d'exploiter les diff\u00e9rences entre monstres et sorceleurs en cr\u00e9ant deux classes diff\u00e9rentes, ayant des m\u00e9thodes sp\u00e9cifiques traduisant les pouvoirs de chacun. Cours A. Syntaxe de la programmation orient\u00e9e objet (POO) Dans le code ci-dessous, entourer la partie correspondant \u00e0 la d\u00e9finition de la classe Exemple d'une couleur, et la partie correspondant \u00e0 son utilisation d'une autre couleur. class Exemple: def __init__(self, param1, param2): self.attribut1 = param1 self.attribut2 = param2 def methode(self, param): #traitement sur le param\u00e8tre def accesseur_att1(self): return self.attribut1 def mutateur_att1(self, val): self.attribut1 = val e = Exemple() #cr\u00e9ation d'un objet a1 = e.accesseur_att1() e.mutateur_att1(5) #en supposant que attribut1 est de type int Compl\u00e9ter les d\u00e9finitions suivantes : Une classe regroupe un ensemble de propri\u00e9t\u00e9s (ses attributs ) et de comportements (ses m\u00e9thodes ) communes \u00e0 diff\u00e9rents objets. Un objet est un \u00e9l\u00e9ment, une instance d'une classe. Un attribut d'un objet est une caract\u00e9ristique, une propri\u00e9t\u00e9 commune \u00e0 tous les objets de la classe. Une m\u00e9thode est une fonction d'une classe, traduisant le comportement de ses objets. Elle ne peut s'appliquer que sur les objets de la classe. Le constructeur de la classe ( __init__ ) est une m\u00e9thode particuli\u00e8re, appel\u00e9e \u00e0 la cr\u00e9ation de chaque nouvel objet. Il initialise ses attributs. Les autres m\u00e9thodes manipulent les attributs : elles peuvent chercher \u00e0 y acc\u00e9der ( accesseurs ou \"getters \") ou \u00e0 les modifier ( mutateurs ou \"setters\" ). \\pagebreak B. Exemple class Guitare: def __init__(self, t, m): self.type = t self.marque = m self.notes = [0,0,0,0,0,0] #repr\u00e9sente les 6 cordes, et le fret s\u00e9lectionn\u00e9 pour jouer un accord par un int def joue(self,n): self.notes = n def ecoute_son(self): return self.notes gfolk = Guitare(\"folk\", \"Fender\") gelec = Guitare(\"\u00e9lectrique\", \"Gibson\") gelec.joue([0,3,2,0,1,0]) #accord de do s = gelec.ecoute_son() Exercices Exercice 1 : (sur feuille, \u00e0 tester sur ordinateur) class Chat: def __init__(self): self.faim = 0 self.fatigue = 0 def bonjour(self): print(\"Miaou !\") def joue(self): self.faim = self.faim+1 self.fatigue = self.fatigue+1 class Chien: def __init__(self): self.faim = 0 self.fatigue = 0 def bonjour(self): print(\"Ouaf !\") def joue(self): self.faim = self.faim+1 self.fatigue = self.fatigue+1 Quel est l'int\u00e9r\u00eat ici d'avoir d\u00e9fini deux classes diff\u00e9rentes pour les chiens et pour les chats ? Cr\u00e9er un objet de la classe Chat , un objet de la classe Chien , et les faire se dire bonjour. La fonction isinstance(objet, classe) de Python teste si objet appartient \u00e0 classe . On veut modifier les deux m\u00e9thodes bonjour pour leur donner en param\u00e8tre l'animal auquel est dit bonjour et faire que : un chat dise bonjour \u00e0 un autre chat, mais ignore un chien, un chien dise bonjour \u00e0 un autre chien, et essaye de faire peur \u00e0 un chat en aboyant plus fort : \"OUAF !\". Tester les m\u00e9thodes obtenues. Proposer une autre impl\u00e9mentation utilisant une seule classe Animal , sans perdre l'information que l'on peut avoir des chats ou bien des chiens. Reprendre la version initiale de se saluer des animaux. La tester en cr\u00e9ant des instances de la classe. Ecrire une m\u00e9thode mange et une m\u00e9thode repos dans la classe Animal d\u00e9cr\u00e9mentant respectivement l'attribut faim de 1, et l'attribut fatigue de 2. Exercice 2 : (sur feuille, \u00e0 tester sur ordinateur) from math import sqrt class Astre: '''Corps c\u00e9lestes, d\u00e9finis par leurs propri\u00e9t\u00e9s physiques.''' def __init__(self, m, p): self.masse = m self.position = p def distance(self, astre): return ... L'attribut position est une liste Python contenant deux \u00e9l\u00e9ments : sa coordonn\u00e9e en x et sa coordonn\u00e9e en y (on se situe dans le plan, pas en 3D) . Pour calculer la distance entre deux astres de position, respectivement, (x1, y1) et (x2, y2), on utilise la formule math\u00e9matique suivante : \\(d = \\sqrt{ (x_{1}-x_{2})^2 + (y_{1}-y_{2})^2 }\\) Compl\u00e9ter la d\u00e9finition de la m\u00e9thode distance . Un astre peut peser entre 0.07 et 300 fois la masse solaire, elle-m\u00eame de \\(2*10^{30}\\) . Cr\u00e9er deux objets de la classe Astre , de masse minimale et maximale et respectivement de position [15,34] et [6,27]. Calculer la distance entre ces deux objets. Exercice 3 : les attributs priv\u00e9s (sur ordinateur) Les valeurs des attributs des objets Python sont par d\u00e9faut modifiables apr\u00e8s la cr\u00e9ation de l'objet. Il est possible d'interdire la modification des attributs en le d\u00e9clarant avec deux tirets bas avant son nom : __x par exemple. Ils sont alors priv\u00e9s : on ne peut pas les manipuler en dehors de la d\u00e9finition de la classe. C'est une bonne pratique d'utiliser des attributs priv\u00e9s, et c'est ce qui rend les accesseurs et mutateurs n\u00e9cessaires. On rend priv\u00e9s les attributs de la classe Chat de l'exercice 1: class Chat: def __init__(self): self.__faim = 0 self.__fatigue = 0 Cr\u00e9er un objet de la classe. Que se passe-t-il si on tente d'acc\u00e9der \u00e0 ses attributs ? Cr\u00e9er les accesseurs et mutateurs n\u00e9cessaire pour r\u00e9cup\u00e9rer la valeur des deux attributs et pouvoir la modifier. Les tester sur un exemple d'objet. Exercice 4 : les classes de Python (sur ordinateur) Les types Python sont impl\u00e9ment\u00e9s par des classes. Afficher la valeur de l'attribut __class__ des expressions suivantes : () , [] , {} , int(0) . En d\u00e9duire comment utiliser la fonction isinstance de l'exercice 3 pour tester si une valeur est un entier, une liste, un tuple, ou bien un dictionnaire. Utiliser cette fonction pour \u00e9crire une fonction separe qui prend en argument une liste Python et s\u00e9pare les cha\u00eenes de caract\u00e8res des entiers qu'elle contient (c'est une mauvaise pratique de m\u00e9langer les deux !) . Exemple : entiers, caracteres = separe([1, \"a\", 666, \"blablabla\", \"nsi\"]) >>> entiers [1,666] >>> caracteres [\"a\", \"blablabla\", \"nsi\"] Exercice 5 : paradigmes objet et imp\u00e9ratif (sur feuille, \u00e0 tester sur ordinateur) Reprendre l'exemple de l'exercice 2. L'objectif est de traduire ce code utilisant le paradigme objet en un code purement imp\u00e9ratif. Pour cela : - On utilise un dictionnaire pour stocker les valeurs des attributs d'un objet (c'est comme \u00e7a que fait Python en r\u00e9alit\u00e9 !) . - On r\u00e9d\u00e9finit les m\u00e9thodes comme de simples fonctions. Utiliser les m\u00eames exemples que dans l'exercice 2. Probl\u00e8me : Gestion d'adresses IP On rappelle qu'une adresse IPv4 est une adresse de 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re le r\u00e9seau priv\u00e9 192.168.1.0. A quoi sert l'adresse IP attribu\u00e9e \u00e0 une machine ? Ecrire cette adresse en binaire, en faisant appara\u00eetre tous les bits utilis\u00e9s. 192.168.1.0 est une adresse r\u00e9serv\u00e9e, la \"premi\u00e8re\" du r\u00e9seau. On consid\u00e8re qu'on ne peut pas modifier les trois premiers octets pour trouver une adresse \u00e0 attribuer \u00e0 une machine. On ne peut pas non plus utiliser la \"derni\u00e8re\" adresse : celle correspondant au nombre le plus \u00e9lev\u00e9 \u00e9crit sur le dernier octet. Quelle est cette \"derni\u00e8re\" adresse ? En d\u00e9duire le nombre d'adresses de ce r\u00e9seau qui peuvent \u00eatre attribu\u00e9es \u00e0 des machines. Donner une adresse de ce r\u00e9seau utilisable en \u00e9criture d\u00e9cimale, et en binaire. Pour parcourir les adresses utilisables, on d\u00e9finit une classe AdresseIP : class AdresseIP: def __init__(self, adresse): self.adresse = ... def liste_octets(self): \"\"\" Renvoie une liste Python de nombres entiers, la liste des octets de l'adresse IP \"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\" Renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon \"\"\" return ... or ... def adresse_suivante(self): \"\"\" Renvoie un objet de AdresseIP avec l'adresse IP qui soit celle du self si elle existe, None sinon \"\"\" if ... < 254: nouvel_octet = ... return AdresseIP('192.168.1.' + ...) else: return None Compl\u00e9ter le constructeur de cette classe. Compl\u00e9ter la m\u00e9thode est_reservee , permettant d'exclure les adresses identifi\u00e9es dans la question 2. Compl\u00e9ter la m\u00e9thode adresse_suivante , en utilisant liste_octets . Cr\u00e9er les objets de la classe ayant pour attribut : 192.168.1.1 , 192.168.1.0 et 192.168.1.254 . Tester les m\u00e9thodes est_reservee et adresse_suivante sur ces objets pour v\u00e9rifier leur bon fonctionnement.","title":"II. Paradigme objet"},{"location":"tle/seq1/POO/#sequence-1","text":"","title":"S\u00e9quence 1"},{"location":"tle/seq1/POO/#ii-le-paradigme-oriente-objet","text":"","title":"II. Le paradigme orient\u00e9 objet"},{"location":"tle/seq1/POO/#tp-un-combat-de-monstres","text":"Dans ce TP, vous utiliserez un seul fichier Python que vous modifierez au fur et \u00e0 mesure. Enregistrez-le au d\u00e9but du TP. Dans l'univers de la s\u00e9rie du Sorceleur de l'\u00e9crivain Andrzej Sapkowski, diff\u00e9rents types de personnages s'affrontent. Certains ont des caract\u00e9ristiques particuli\u00e8res comme les sorceleurs qui sont tr\u00e8s habiles au combat et ma\u00eetrisent une certaine forme de magie. Il sont charg\u00e9s d'\u00e9liminer les monstres pr\u00e9sents sur le continent. Pour repr\u00e9senter une situation de mani\u00e8re r\u00e9aliste, le paradigme dit \"objet\" est le plus appropri\u00e9. Il permet de mod\u00e9liser des \u00e9l\u00e9ments du monde r\u00e9el ou bien des concepts. Ce paradigme utilise des classes, une classe pouvant d\u00e9finir aussi bien un animal, qu'un v\u00e9hicule, un humain, un steak, un schtroumpf... Les \u00e9l\u00e9ments de ces classes sont des objets , que nous allons utiliser pour repr\u00e9senter des sorceleurs et des monstres. Impl\u00e9menter le code suivant : class Personnage: # d\u00e9finition de la classe pass # pour l'instant, elle ne fait rien geralt = Personnage() # cr\u00e9ation d'un \u00e9l\u00e9ment de la classe : un objet monstre = Personnage() # cr\u00e9ation d'un deuxi\u00e8me objet Tous les objets de la classe Sorceleur auront les m\u00eames caract\u00e9ristiques : des variables nomm\u00e9es attributs , et les m\u00eames comportements d\u00e9finis par des fonctions appel\u00e9es m\u00e9thodes . Parmi les caract\u00e9ristiques des sorceleurs, on peut avoir leur nombre de points de vie. Impl\u00e9menter le code suivant : class Personnage: def __init__(self): # cette fonction est une m\u00e9thode de la classe Sorceleur nomm\u00e9e \"constructeur\" : utilis\u00e9e pour \"construire\" chaque nouvel objet self.vie = 50 # on attribue 50 points de vie par d\u00e9faut \u00e0 tout nouveau sorceleur geralt = Personnage() monstre = Personnage() Taper dans la console : geralt.vie et monstre.vie et v\u00e9rifier que la valeur attribu\u00e9e \u00e0 l'attribue vie est correcte. On peut vouloir d\u00e9finir au moment de la cr\u00e9ation de chaque objet une valeur initiale de points de vie diff\u00e9rente pour chacun. Modifions le programme : class Personnage: def __init__(self, v): # la valeur est donn\u00e9e en param\u00e8tre du constructeur self.vie = v geralt = Personnage() monstre = Personnage() V\u00e9rifier que le nombre de points de vie de chacun est correct. Un constructeur peut avoir plusieurs arguments, mais il a toujours au moins l'argument self qui fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame. self est n\u00e9cessaire pour acc\u00e9der aux attributs et aux m\u00e9thodes \u00e0 l'int\u00e9rieur de la classe. Il n'existe plus \u00e0 l'ext\u00e9rieur. Ajoutons quelques m\u00e9thodes \u00e0 notre classe pour mieux simuler le comportement des personnages : class Personnage: def __init__(self, v): self.vie = v def perd_vie(self): self.vie = self.vie - 1 def donne_etat(self): return self.vie geralt = Personnage(50) geralt.perd_vie() pts = geralt.donne_etat() Que vaut la variable pts ? Modifier la m\u00e9thode perd_vie pour que le nombre de points perdus soit d\u00e9fini al\u00e9atoirement \u00e0 l'aide de la fonction randint de la biblioth\u00e8que du random : elle retournera un entier entre 1 et 10 qui correspondra au nombre de points perdus. from random import randint # instruction pour importer la fonction help(randint) \"commande pour extraire la documentation de la fonction\" Ajouter un attribut exp repr\u00e9sentant l'exp\u00e9rience du personnage. Cr\u00e9er les m\u00e9thodes gagne_exp et donne_exp permettant, respectivement, de faire gagner une valeur e d'exp\u00e9rience, et de consulter la valeur de l'attribut exp . Cr\u00e9er un programme principal dans lequel geralt affronte monstre selon les r\u00e8gles suivantes : Chacun attaque l'autre \u00e0 tour de r\u00f4le jusqu'\u00e0 ce que le nombre de points de vie d'un des personnages descende \u00e0 0 (ou moins), Si l' exp\u00e9rience d'un personnage est sup\u00e9rieure \u00e0 40, alors son adversaire perd entre 5 et 10 points \u00e0 chaque attaque. Sinon, il perd entre 0 et 5 points. Le vainqueur il gagne 2 points d'exp\u00e9rience. Il peut ensuite combattre un autre adversaire. Attention ! Pour acc\u00e9der aux valeurs des attributs, il faut utiliser les m\u00e9thodes donne_etat et donne_exp . Pour aller plus loin... Vous pouvez \u00e9tendre les possibilit\u00e9s du jeu, par exemple en organisant une sorte de tournoi avec plusieurs sorceleurs et plusieurs monstres. Il est aussi possible d'exploiter les diff\u00e9rences entre monstres et sorceleurs en cr\u00e9ant deux classes diff\u00e9rentes, ayant des m\u00e9thodes sp\u00e9cifiques traduisant les pouvoirs de chacun.","title":"TP : Un combat de monstres"},{"location":"tle/seq1/POO/#cours","text":"","title":"Cours"},{"location":"tle/seq1/POO/#a-syntaxe-de-la-programmation-orientee-objet-poo","text":"Dans le code ci-dessous, entourer la partie correspondant \u00e0 la d\u00e9finition de la classe Exemple d'une couleur, et la partie correspondant \u00e0 son utilisation d'une autre couleur. class Exemple: def __init__(self, param1, param2): self.attribut1 = param1 self.attribut2 = param2 def methode(self, param): #traitement sur le param\u00e8tre def accesseur_att1(self): return self.attribut1 def mutateur_att1(self, val): self.attribut1 = val e = Exemple() #cr\u00e9ation d'un objet a1 = e.accesseur_att1() e.mutateur_att1(5) #en supposant que attribut1 est de type int Compl\u00e9ter les d\u00e9finitions suivantes : Une classe regroupe un ensemble de propri\u00e9t\u00e9s (ses attributs ) et de comportements (ses m\u00e9thodes ) communes \u00e0 diff\u00e9rents objets. Un objet est un \u00e9l\u00e9ment, une instance d'une classe. Un attribut d'un objet est une caract\u00e9ristique, une propri\u00e9t\u00e9 commune \u00e0 tous les objets de la classe. Une m\u00e9thode est une fonction d'une classe, traduisant le comportement de ses objets. Elle ne peut s'appliquer que sur les objets de la classe. Le constructeur de la classe ( __init__ ) est une m\u00e9thode particuli\u00e8re, appel\u00e9e \u00e0 la cr\u00e9ation de chaque nouvel objet. Il initialise ses attributs. Les autres m\u00e9thodes manipulent les attributs : elles peuvent chercher \u00e0 y acc\u00e9der ( accesseurs ou \"getters \") ou \u00e0 les modifier ( mutateurs ou \"setters\" ). \\pagebreak","title":"A. Syntaxe de la programmation orient\u00e9e objet (POO)"},{"location":"tle/seq1/POO/#b-exemple","text":"class Guitare: def __init__(self, t, m): self.type = t self.marque = m self.notes = [0,0,0,0,0,0] #repr\u00e9sente les 6 cordes, et le fret s\u00e9lectionn\u00e9 pour jouer un accord par un int def joue(self,n): self.notes = n def ecoute_son(self): return self.notes gfolk = Guitare(\"folk\", \"Fender\") gelec = Guitare(\"\u00e9lectrique\", \"Gibson\") gelec.joue([0,3,2,0,1,0]) #accord de do s = gelec.ecoute_son()","title":"B. Exemple"},{"location":"tle/seq1/POO/#exercices","text":"","title":"Exercices"},{"location":"tle/seq1/POO/#exercice-1-sur-feuille-a-tester-sur-ordinateur","text":"class Chat: def __init__(self): self.faim = 0 self.fatigue = 0 def bonjour(self): print(\"Miaou !\") def joue(self): self.faim = self.faim+1 self.fatigue = self.fatigue+1 class Chien: def __init__(self): self.faim = 0 self.fatigue = 0 def bonjour(self): print(\"Ouaf !\") def joue(self): self.faim = self.faim+1 self.fatigue = self.fatigue+1 Quel est l'int\u00e9r\u00eat ici d'avoir d\u00e9fini deux classes diff\u00e9rentes pour les chiens et pour les chats ? Cr\u00e9er un objet de la classe Chat , un objet de la classe Chien , et les faire se dire bonjour. La fonction isinstance(objet, classe) de Python teste si objet appartient \u00e0 classe . On veut modifier les deux m\u00e9thodes bonjour pour leur donner en param\u00e8tre l'animal auquel est dit bonjour et faire que : un chat dise bonjour \u00e0 un autre chat, mais ignore un chien, un chien dise bonjour \u00e0 un autre chien, et essaye de faire peur \u00e0 un chat en aboyant plus fort : \"OUAF !\". Tester les m\u00e9thodes obtenues. Proposer une autre impl\u00e9mentation utilisant une seule classe Animal , sans perdre l'information que l'on peut avoir des chats ou bien des chiens. Reprendre la version initiale de se saluer des animaux. La tester en cr\u00e9ant des instances de la classe. Ecrire une m\u00e9thode mange et une m\u00e9thode repos dans la classe Animal d\u00e9cr\u00e9mentant respectivement l'attribut faim de 1, et l'attribut fatigue de 2.","title":"Exercice 1 : (sur feuille, \u00e0 tester sur ordinateur)"},{"location":"tle/seq1/POO/#exercice-2-sur-feuille-a-tester-sur-ordinateur","text":"from math import sqrt class Astre: '''Corps c\u00e9lestes, d\u00e9finis par leurs propri\u00e9t\u00e9s physiques.''' def __init__(self, m, p): self.masse = m self.position = p def distance(self, astre): return ... L'attribut position est une liste Python contenant deux \u00e9l\u00e9ments : sa coordonn\u00e9e en x et sa coordonn\u00e9e en y (on se situe dans le plan, pas en 3D) . Pour calculer la distance entre deux astres de position, respectivement, (x1, y1) et (x2, y2), on utilise la formule math\u00e9matique suivante : \\(d = \\sqrt{ (x_{1}-x_{2})^2 + (y_{1}-y_{2})^2 }\\) Compl\u00e9ter la d\u00e9finition de la m\u00e9thode distance . Un astre peut peser entre 0.07 et 300 fois la masse solaire, elle-m\u00eame de \\(2*10^{30}\\) . Cr\u00e9er deux objets de la classe Astre , de masse minimale et maximale et respectivement de position [15,34] et [6,27]. Calculer la distance entre ces deux objets.","title":"Exercice 2 : (sur feuille, \u00e0 tester sur ordinateur)"},{"location":"tle/seq1/POO/#exercice-3-les-attributs-prives-sur-ordinateur","text":"Les valeurs des attributs des objets Python sont par d\u00e9faut modifiables apr\u00e8s la cr\u00e9ation de l'objet. Il est possible d'interdire la modification des attributs en le d\u00e9clarant avec deux tirets bas avant son nom : __x par exemple. Ils sont alors priv\u00e9s : on ne peut pas les manipuler en dehors de la d\u00e9finition de la classe. C'est une bonne pratique d'utiliser des attributs priv\u00e9s, et c'est ce qui rend les accesseurs et mutateurs n\u00e9cessaires. On rend priv\u00e9s les attributs de la classe Chat de l'exercice 1: class Chat: def __init__(self): self.__faim = 0 self.__fatigue = 0 Cr\u00e9er un objet de la classe. Que se passe-t-il si on tente d'acc\u00e9der \u00e0 ses attributs ? Cr\u00e9er les accesseurs et mutateurs n\u00e9cessaire pour r\u00e9cup\u00e9rer la valeur des deux attributs et pouvoir la modifier. Les tester sur un exemple d'objet.","title":"Exercice 3 : les attributs priv\u00e9s (sur ordinateur)"},{"location":"tle/seq1/POO/#exercice-4-les-classes-de-python-sur-ordinateur","text":"Les types Python sont impl\u00e9ment\u00e9s par des classes. Afficher la valeur de l'attribut __class__ des expressions suivantes : () , [] , {} , int(0) . En d\u00e9duire comment utiliser la fonction isinstance de l'exercice 3 pour tester si une valeur est un entier, une liste, un tuple, ou bien un dictionnaire. Utiliser cette fonction pour \u00e9crire une fonction separe qui prend en argument une liste Python et s\u00e9pare les cha\u00eenes de caract\u00e8res des entiers qu'elle contient (c'est une mauvaise pratique de m\u00e9langer les deux !) . Exemple : entiers, caracteres = separe([1, \"a\", 666, \"blablabla\", \"nsi\"]) >>> entiers [1,666] >>> caracteres [\"a\", \"blablabla\", \"nsi\"]","title":"Exercice 4 : les classes de Python (sur ordinateur)"},{"location":"tle/seq1/POO/#exercice-5-paradigmes-objet-et-imperatif-sur-feuille-a-tester-sur-ordinateur","text":"Reprendre l'exemple de l'exercice 2. L'objectif est de traduire ce code utilisant le paradigme objet en un code purement imp\u00e9ratif. Pour cela : - On utilise un dictionnaire pour stocker les valeurs des attributs d'un objet (c'est comme \u00e7a que fait Python en r\u00e9alit\u00e9 !) . - On r\u00e9d\u00e9finit les m\u00e9thodes comme de simples fonctions. Utiliser les m\u00eames exemples que dans l'exercice 2.","title":"Exercice 5 : paradigmes objet et imp\u00e9ratif (sur feuille, \u00e0 tester sur ordinateur)"},{"location":"tle/seq1/POO/#probleme-gestion-dadresses-ip","text":"On rappelle qu'une adresse IPv4 est une adresse de 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re le r\u00e9seau priv\u00e9 192.168.1.0. A quoi sert l'adresse IP attribu\u00e9e \u00e0 une machine ? Ecrire cette adresse en binaire, en faisant appara\u00eetre tous les bits utilis\u00e9s. 192.168.1.0 est une adresse r\u00e9serv\u00e9e, la \"premi\u00e8re\" du r\u00e9seau. On consid\u00e8re qu'on ne peut pas modifier les trois premiers octets pour trouver une adresse \u00e0 attribuer \u00e0 une machine. On ne peut pas non plus utiliser la \"derni\u00e8re\" adresse : celle correspondant au nombre le plus \u00e9lev\u00e9 \u00e9crit sur le dernier octet. Quelle est cette \"derni\u00e8re\" adresse ? En d\u00e9duire le nombre d'adresses de ce r\u00e9seau qui peuvent \u00eatre attribu\u00e9es \u00e0 des machines. Donner une adresse de ce r\u00e9seau utilisable en \u00e9criture d\u00e9cimale, et en binaire. Pour parcourir les adresses utilisables, on d\u00e9finit une classe AdresseIP : class AdresseIP: def __init__(self, adresse): self.adresse = ... def liste_octets(self): \"\"\" Renvoie une liste Python de nombres entiers, la liste des octets de l'adresse IP \"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\" Renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon \"\"\" return ... or ... def adresse_suivante(self): \"\"\" Renvoie un objet de AdresseIP avec l'adresse IP qui soit celle du self si elle existe, None sinon \"\"\" if ... < 254: nouvel_octet = ... return AdresseIP('192.168.1.' + ...) else: return None Compl\u00e9ter le constructeur de cette classe. Compl\u00e9ter la m\u00e9thode est_reservee , permettant d'exclure les adresses identifi\u00e9es dans la question 2. Compl\u00e9ter la m\u00e9thode adresse_suivante , en utilisant liste_octets . Cr\u00e9er les objets de la classe ayant pour attribut : 192.168.1.1 , 192.168.1.0 et 192.168.1.254 . Tester les m\u00e9thodes est_reservee et adresse_suivante sur ces objets pour v\u00e9rifier leur bon fonctionnement.","title":"Probl\u00e8me : Gestion d'adresses IP"},{"location":"tle/seq1/Synth%C3%A8se_El%C3%A8ve/","text":"body { text-align: justify} S\u00e9quence 1 Synth\u00e8se sur les paradigmes A. Les diff\u00e9rents paradigmes Programmation imp\u00e9rative Programmation fonctionnelle Programmation orient\u00e9e objet Principe g\u00e9n\u00e9ral Avantage Cas d'usage courant Compl\u00e9ter le tableau r\u00e9capitulatif sur les 3 paradigmes vus dans le cours, en indiquant leur principe et leurs avantages . Associer les diff\u00e9rents paradigmes \u00e0 un cas d'usage/champ d'application parmi la liste ci-dessous : calculs math\u00e9matiques - traitement de donn\u00e9es - d\u00e9veloppement de jeu vid\u00e9o B. Langages et paradigmes Les langages informatiques sont souvent pens\u00e9s pour un paradigme, mais aujourd'hui beaucoup d'entre eux sont multi-paradigmes pour permettre plus de flexibilit\u00e9 et toucher plus de programmeurs. C'est le cas de Python, langage imp\u00e9ratif mais pouvant utiliser des caract\u00e9ristiques fonctionnelles et permettant la POO. Les langages \u00e9voluent avec les pratiques des d\u00e9veloppeurs. Le succ\u00e8s de la POO a fait qu'elle a \u00e9t\u00e9 incorpor\u00e9e \u00e0 des langages con\u00e7us \u00e0 l'origine pour d'autres paradigmes. Par exemple, C++ est une version \"am\u00e9lior\u00e9e\" du C (langage imp\u00e9ratif) qui permet d'utiliser la POO. De m\u00eame, Caml est un langage tr\u00e8s fonctionnel, utilis\u00e9 notamment pour faire des preuves de programmes, qui incorpore la programmation objet dans son \u00e9volution OCaml (\"Objective Caml\"). Plus g\u00e9n\u00e9ralement, il est possible d'int\u00e9grer plusieurs langages dans le d\u00e9veloppement d'un logiciel, pour exploiter le meilleur de chacun.","title":"Synth\u00e8se"},{"location":"tle/seq1/Synth%C3%A8se_El%C3%A8ve/#sequence-1","text":"","title":"S\u00e9quence 1"},{"location":"tle/seq1/Synth%C3%A8se_El%C3%A8ve/#synthese-sur-les-paradigmes","text":"","title":"Synth\u00e8se sur les paradigmes"},{"location":"tle/seq1/Synth%C3%A8se_El%C3%A8ve/#a-les-differents-paradigmes","text":"Programmation imp\u00e9rative Programmation fonctionnelle Programmation orient\u00e9e objet Principe g\u00e9n\u00e9ral Avantage Cas d'usage courant Compl\u00e9ter le tableau r\u00e9capitulatif sur les 3 paradigmes vus dans le cours, en indiquant leur principe et leurs avantages . Associer les diff\u00e9rents paradigmes \u00e0 un cas d'usage/champ d'application parmi la liste ci-dessous : calculs math\u00e9matiques - traitement de donn\u00e9es - d\u00e9veloppement de jeu vid\u00e9o","title":"A. Les diff\u00e9rents paradigmes"},{"location":"tle/seq1/Synth%C3%A8se_El%C3%A8ve/#b-langages-et-paradigmes","text":"Les langages informatiques sont souvent pens\u00e9s pour un paradigme, mais aujourd'hui beaucoup d'entre eux sont multi-paradigmes pour permettre plus de flexibilit\u00e9 et toucher plus de programmeurs. C'est le cas de Python, langage imp\u00e9ratif mais pouvant utiliser des caract\u00e9ristiques fonctionnelles et permettant la POO. Les langages \u00e9voluent avec les pratiques des d\u00e9veloppeurs. Le succ\u00e8s de la POO a fait qu'elle a \u00e9t\u00e9 incorpor\u00e9e \u00e0 des langages con\u00e7us \u00e0 l'origine pour d'autres paradigmes. Par exemple, C++ est une version \"am\u00e9lior\u00e9e\" du C (langage imp\u00e9ratif) qui permet d'utiliser la POO. De m\u00eame, Caml est un langage tr\u00e8s fonctionnel, utilis\u00e9 notamment pour faire des preuves de programmes, qui incorpore la programmation objet dans son \u00e9volution OCaml (\"Objective Caml\"). Plus g\u00e9n\u00e9ralement, il est possible d'int\u00e9grer plusieurs langages dans le d\u00e9veloppement d'un logiciel, pour exploiter le meilleur de chacun.","title":"B. Langages et paradigmes"},{"location":"tle/seq2/diviser_regner/","text":"body { text-align: justify} S\u00e9quence 2 III. Diviser pour r\u00e9gner Cours A. Notions d'algorithmique Qu'est-ce qu'un algorithme ? Un algorithme est une suite d'instructions permettant de r\u00e9soudre un probl\u00e8me. Qu'est-ce que la complexit\u00e9 d'un algorithme ? La complexit\u00e9 d'un algorithme \u00e9value la quantit\u00e9 de ressources (en temps, en m\u00e9moire), n\u00e9cessaire \u00e0 son ex\u00e9cution. A quoi sert l'\u00e9valuation de cette complexit\u00e9 ? Evaluer la complexit\u00e9 d'un algorithme sert \u00e0 le comparer \u00e0 d'autres algorithmes r\u00e9solvant le m\u00eame probl\u00e8me. Dans le programme de NSI, on s'int\u00e9resse \u00e0 la complexit\u00e9 en temps dans le pire des cas . Qu'\u00e9value-t-on alors ? On estime le nombre d'op\u00e9rations \u00e9l\u00e9mentaires ex\u00e9cut\u00e9es, en fonction de la taille des donn\u00e9es d'entr\u00e9e not\u00e9e n. Tracer les diff\u00e9rent types de complexit\u00e9s que vous connaissez sur un graphique. En donner des exemples types d'algorithmes associ\u00e9s. - constant : retour d'une valeur (la moiti\u00e9 d'un nombre, test,...) - lin\u00e9aire : parcours d'un tableau, 1 boucle - quadratique : parcours d'un tableau \u00e0 deux dimensions, 2 boucles imbriqu\u00e9es B. Les algorithmes du type \"diviser pour r\u00e9gner\" \"Diviser pour r\u00e9gner\" est une m\u00e9thode algorithmique : une mani\u00e8re de r\u00e9soudre des probl\u00e8mes algorithmiquement. Son principe est, lorsque l'on consid\u00e8re un probl\u00e8me, de le d\u00e9couper en plusieurs sous-probl\u00e8mes \u00e9quivalents, mais de taille plus r\u00e9duite. Ces \"petits probl\u00e8mes\" seront plus simples \u00e0 r\u00e9soudre que le probl\u00e8me initial. Une fois les \"petits probl\u00e8mes\" r\u00e9solus, il faut les recombiner pour obtenir une solution au probl\u00e8me initial. Les trois principes \u00e0 la base de cette m\u00e9thode de \"diviser pour r\u00e9gner\" sont : - Diviser : on divise le probl\u00e8me initial en sous-probl\u00e8mes - R\u00e9gner : on r\u00e9soud les sous-probl\u00e8mes - Combiner : on combine les solutions des sous-probl\u00e8mes, pour avoir la solution du probl\u00e8me initial Le principe de la r\u00e9cursivit\u00e9 \u00e9tant similaire \u00e0 celui de cette approche, on utilise souvent des algorithmes r\u00e9cursifs . Cela n'est pas obligatoire ! Une approche \"diviser pour r\u00e9gner\" peut aussi \u00eatre it\u00e9rative (avec des boucles). c. Le tri fusion C.1. Principe et exemple Le tri fusion est une mani\u00e8re de trier une liste en la divisant successivement, puis en fusionnant petit \u00e0 petit les sous-listes tri\u00e9es pour finalement en obtenir une seule : la liste initiale tri\u00e9e. Les trois \u00e9tapes de cet algorithme sont : - Diviser : on divise le tableau successivement en deux, jusqu'\u00e0 obtenir des tableaux de taille 1. - R\u00e9gner : on obtient un tableau de taille 1 qui est tri\u00e9. A chaque nouvelle fusion, on s'assure que le r\u00e9sultat est tri\u00e9. - Combiner : on fusionne les tableaux tri\u00e9s deux \u00e0 deux, jusqu'\u00e0 en obtenir une seule. C.2. Comparaison avec les autres algorithmes de tri Rappeler les principe des deux algorithmes de tri du programme de 1\u00e8re : Tri par s\u00e9lection Tri par insertion On s\u00e9lectionne le minimum du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment en premi\u00e8re position. On prend le 2\u00e8me \u00e9l\u00e9ment, on le compare avec le premier, et on \u00e9change les deux s'ils ne sont pas rang\u00e9s dans l'ordre croissant. On s\u00e9lectionne le minimum de l'ensemble des \u00e9l\u00e9ments du tableau sauf le premier, et on l'\u00e9change avec celui en 2\u00e8me position. On prend le 3\u00e8me \u00e9l\u00e9ment, on le compare avec les pr\u00e9c\u00e9dents jusqu'\u00e0 trouver un \u00e9l\u00e9ment plus petit que lui. On l'\u00e9change avec le dernier \u00e9l\u00e9ment plus grand. On r\u00e9p\u00e8te ces op\u00e9rations, en r\u00e9duisant de un en un la partie du tableau consid\u00e9r\u00e9e, jusqu'\u00e0 l'avant-dernier \u00e9l\u00e9ment. On r\u00e9p\u00e8te ces op\u00e9rations en parcourant de un en un les \u00e9l\u00e9ments du tableau, jusqu'au dernier. Quel est le type de complexit\u00e9 de ces deux algorithmes ? Ces algorithmes ont une complexit\u00e9 quadratique (en \\(n^2\\) ). La complexit\u00e9 du tri fusion est en \\(nlog(n)\\) . Est-il donc judicieux de l'utiliser \u00e0 la place d'un tri par s\u00e9lection ou par insertion ? Il est pertinent d'utiliser le tri fusion, car sa complexit\u00e9 est meilleure : la courbe la repr\u00e9sentant se trouve en-dessous de la courbe de la fonction quadratique, pour une valeur de n donn\u00e9e. TP : Le tri fusion A. Application Appliquer l'algorithme du tri fusion sur l'exemple ci-contre, en compl\u00e9tant le sch\u00e9ma avec les divisions et recombinaisons successives. Dans le cas d'un tableau ayant un nombre impair d'\u00e9l\u00e9ments, on peut consid\u00e9rer que le tableau le plus petit va se retrouver \u00e0 gauche, le plus grand \u00e0 droite. B. Impl\u00e9mentation L'impl\u00e9mentation du tri fusion se fait classiquement avec deux fonctions : - une fonction principale qui divise le tableau pass\u00e9 en param\u00e8tre par deux, - une fonction qui fait la fusion entre deux tableaux tri\u00e9s. B.1. La fusion Elle peut \u00eatre \u00e9crite de mani\u00e8re r\u00e9cursive ou bien it\u00e9rative . Tester les deux versions sur les listes [1,4,7,9] et [-2,0,3,8] . Version it\u00e9rative : Compl\u00e9ter le code suivant : def fusion_it(T1, T2): taille_1 = len(T1) taille_2 = len(T2) T_trie = [] i1 = 0 i2 = 0 while (i1 < taille_1) and (...): if T1[i1] < T2[i2]: T_trie.append(...[i1]) i1 = ... else: T_trie.append(T2[...]) i2 = ... while i1 < taille_1: T_trie.append(...) i1 = ... while i2 < taille_2: T_trie.append(...) ... return T_trie Version r\u00e9cursive : On donne le squelette de la fonction, \u00e0 compl\u00e9ter : def fusion_rec(T1,T2): if ............ # premier cas de base, pour une valeur triviale de T1 return T2 elif ........... # deuxi\u00e8me cas de base, pour une valeur triviale de T2 return T1 elif T1[0] < T2[0]: return [.....] + fusion(........, .........) # on place le bon \u00e9l\u00e9ment en premier else: return [.....] + fusion(........, .........) B.2. Le tri complet La fonction permettant de trier compl\u00e8tement le tableau divise d'abord en deux le tableau initial, avant de fusionner les r\u00e9sultats des tris sur la premi\u00e8re, et la deuxi\u00e8me partie du tableau. Compl\u00e9ter le code suivant : def tri_fusion(tab): if .................... # cas de base return tab else: # on coupe le tableau en deux sous-tableaux t1 = [tab[i] for i in range(.......)] t2 = [tab[i] for i in range(.......)] return fusion(tri_fusion(.....), tri_fusion(.....)) Pour prendre les deux moiti\u00e9s du tableau, on aurait pu faire du slicing . Cette m\u00e9thode a aussi des d\u00e9savantages, il est utile de conna\u00eetre plusieurs m\u00e9thodes pour s\u00e9lectionner une partie d'un tableau. TP : La recherche dichotomique La recherche dichotomique d'un \u00e9l\u00e9ment e dans un tableau tri\u00e9 consiste : 1. A comparer e avec celui au milieu du tableau : - si e est plus grand, on continue la recherche dans la partie droite du tableau. - sinon, on continue la recherche dans la partie gauche du tableau. 2. On recommence en comparant e avec le milieu de la partie du tableau consid\u00e9r\u00e9e, et ainsi de suite. 3. L'algorithme termine lorsque e est trouv\u00e9, ou bien si l'on arrive sur le tableau vide. Appliquer l'algorithme pour rechercher 10 dans [1,6,10,15,17,20] . Rechercher 5 dans ce m\u00eame tableau. Compl\u00e9ter la version r\u00e9cursive suivante : def recherche_dichotomique_rec(t, elt, inf, sup): \"\"\"Version r\u00e9cursive de la recherche dichotomique d'un \u00e9l\u00e9ment dans un tableau tri\u00e9' Entr\u00e9es : t : liste Python (tableau) d'entiers ou de flottants tri\u00e9e elt : entier ou flottant recherch\u00e9 inf, sup : entiers correspondant respectivement \u00e0 l'indice inf\u00e9rieur et sup\u00e9rieur de la partie de t consid\u00e9r\u00e9e Sortie : entier, valant -1 si l'\u00e9lement n'est pas trouv\u00e9, l'indice de l'\u00e9l\u00e9ment trouv\u00e9 dans le tableau sinon \"\"\" mil = (sup+inf)//2 if sup<inf: return ... elif ... return mil elif elt > t[mil]: return recherche_dichotomique_rec(t, elt, ..., ...) else: return recherche_dichotomique_rec(t, elt, ..., ...) \u00c9crire une fonction recherche it\u00e9rative qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. N.B. : Cette version, du programme de 1\u00e8re, utilise une boucle while \u00e0 la place de l'appel r\u00e9cursif de la version pr\u00e9c\u00e9dente.","title":"III. Diviser pour r\u00e9gner"},{"location":"tle/seq2/diviser_regner/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"tle/seq2/diviser_regner/#iii-diviser-pour-regner","text":"","title":"III. Diviser pour r\u00e9gner"},{"location":"tle/seq2/diviser_regner/#cours","text":"","title":"Cours"},{"location":"tle/seq2/diviser_regner/#a-notions-dalgorithmique","text":"Qu'est-ce qu'un algorithme ? Un algorithme est une suite d'instructions permettant de r\u00e9soudre un probl\u00e8me. Qu'est-ce que la complexit\u00e9 d'un algorithme ? La complexit\u00e9 d'un algorithme \u00e9value la quantit\u00e9 de ressources (en temps, en m\u00e9moire), n\u00e9cessaire \u00e0 son ex\u00e9cution. A quoi sert l'\u00e9valuation de cette complexit\u00e9 ? Evaluer la complexit\u00e9 d'un algorithme sert \u00e0 le comparer \u00e0 d'autres algorithmes r\u00e9solvant le m\u00eame probl\u00e8me. Dans le programme de NSI, on s'int\u00e9resse \u00e0 la complexit\u00e9 en temps dans le pire des cas . Qu'\u00e9value-t-on alors ? On estime le nombre d'op\u00e9rations \u00e9l\u00e9mentaires ex\u00e9cut\u00e9es, en fonction de la taille des donn\u00e9es d'entr\u00e9e not\u00e9e n. Tracer les diff\u00e9rent types de complexit\u00e9s que vous connaissez sur un graphique. En donner des exemples types d'algorithmes associ\u00e9s. - constant : retour d'une valeur (la moiti\u00e9 d'un nombre, test,...) - lin\u00e9aire : parcours d'un tableau, 1 boucle - quadratique : parcours d'un tableau \u00e0 deux dimensions, 2 boucles imbriqu\u00e9es","title":"A. Notions d'algorithmique"},{"location":"tle/seq2/diviser_regner/#b-les-algorithmes-du-type-diviser-pour-regner","text":"\"Diviser pour r\u00e9gner\" est une m\u00e9thode algorithmique : une mani\u00e8re de r\u00e9soudre des probl\u00e8mes algorithmiquement. Son principe est, lorsque l'on consid\u00e8re un probl\u00e8me, de le d\u00e9couper en plusieurs sous-probl\u00e8mes \u00e9quivalents, mais de taille plus r\u00e9duite. Ces \"petits probl\u00e8mes\" seront plus simples \u00e0 r\u00e9soudre que le probl\u00e8me initial. Une fois les \"petits probl\u00e8mes\" r\u00e9solus, il faut les recombiner pour obtenir une solution au probl\u00e8me initial. Les trois principes \u00e0 la base de cette m\u00e9thode de \"diviser pour r\u00e9gner\" sont : - Diviser : on divise le probl\u00e8me initial en sous-probl\u00e8mes - R\u00e9gner : on r\u00e9soud les sous-probl\u00e8mes - Combiner : on combine les solutions des sous-probl\u00e8mes, pour avoir la solution du probl\u00e8me initial Le principe de la r\u00e9cursivit\u00e9 \u00e9tant similaire \u00e0 celui de cette approche, on utilise souvent des algorithmes r\u00e9cursifs . Cela n'est pas obligatoire ! Une approche \"diviser pour r\u00e9gner\" peut aussi \u00eatre it\u00e9rative (avec des boucles).","title":"B. Les algorithmes du type \"diviser pour r\u00e9gner\""},{"location":"tle/seq2/diviser_regner/#c-le-tri-fusion","text":"","title":"c. Le tri fusion"},{"location":"tle/seq2/diviser_regner/#c1-principe-et-exemple","text":"Le tri fusion est une mani\u00e8re de trier une liste en la divisant successivement, puis en fusionnant petit \u00e0 petit les sous-listes tri\u00e9es pour finalement en obtenir une seule : la liste initiale tri\u00e9e. Les trois \u00e9tapes de cet algorithme sont : - Diviser : on divise le tableau successivement en deux, jusqu'\u00e0 obtenir des tableaux de taille 1. - R\u00e9gner : on obtient un tableau de taille 1 qui est tri\u00e9. A chaque nouvelle fusion, on s'assure que le r\u00e9sultat est tri\u00e9. - Combiner : on fusionne les tableaux tri\u00e9s deux \u00e0 deux, jusqu'\u00e0 en obtenir une seule.","title":"C.1. Principe et exemple"},{"location":"tle/seq2/diviser_regner/#c2-comparaison-avec-les-autres-algorithmes-de-tri","text":"Rappeler les principe des deux algorithmes de tri du programme de 1\u00e8re : Tri par s\u00e9lection Tri par insertion On s\u00e9lectionne le minimum du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment en premi\u00e8re position. On prend le 2\u00e8me \u00e9l\u00e9ment, on le compare avec le premier, et on \u00e9change les deux s'ils ne sont pas rang\u00e9s dans l'ordre croissant. On s\u00e9lectionne le minimum de l'ensemble des \u00e9l\u00e9ments du tableau sauf le premier, et on l'\u00e9change avec celui en 2\u00e8me position. On prend le 3\u00e8me \u00e9l\u00e9ment, on le compare avec les pr\u00e9c\u00e9dents jusqu'\u00e0 trouver un \u00e9l\u00e9ment plus petit que lui. On l'\u00e9change avec le dernier \u00e9l\u00e9ment plus grand. On r\u00e9p\u00e8te ces op\u00e9rations, en r\u00e9duisant de un en un la partie du tableau consid\u00e9r\u00e9e, jusqu'\u00e0 l'avant-dernier \u00e9l\u00e9ment. On r\u00e9p\u00e8te ces op\u00e9rations en parcourant de un en un les \u00e9l\u00e9ments du tableau, jusqu'au dernier. Quel est le type de complexit\u00e9 de ces deux algorithmes ? Ces algorithmes ont une complexit\u00e9 quadratique (en \\(n^2\\) ). La complexit\u00e9 du tri fusion est en \\(nlog(n)\\) . Est-il donc judicieux de l'utiliser \u00e0 la place d'un tri par s\u00e9lection ou par insertion ? Il est pertinent d'utiliser le tri fusion, car sa complexit\u00e9 est meilleure : la courbe la repr\u00e9sentant se trouve en-dessous de la courbe de la fonction quadratique, pour une valeur de n donn\u00e9e.","title":"C.2. Comparaison avec les autres algorithmes de tri"},{"location":"tle/seq2/diviser_regner/#tp-le-tri-fusion","text":"","title":"TP : Le tri fusion"},{"location":"tle/seq2/diviser_regner/#a-application","text":"Appliquer l'algorithme du tri fusion sur l'exemple ci-contre, en compl\u00e9tant le sch\u00e9ma avec les divisions et recombinaisons successives. Dans le cas d'un tableau ayant un nombre impair d'\u00e9l\u00e9ments, on peut consid\u00e9rer que le tableau le plus petit va se retrouver \u00e0 gauche, le plus grand \u00e0 droite.","title":"A. Application"},{"location":"tle/seq2/diviser_regner/#b-implementation","text":"L'impl\u00e9mentation du tri fusion se fait classiquement avec deux fonctions : - une fonction principale qui divise le tableau pass\u00e9 en param\u00e8tre par deux, - une fonction qui fait la fusion entre deux tableaux tri\u00e9s.","title":"B. Impl\u00e9mentation"},{"location":"tle/seq2/diviser_regner/#b1-la-fusion","text":"Elle peut \u00eatre \u00e9crite de mani\u00e8re r\u00e9cursive ou bien it\u00e9rative . Tester les deux versions sur les listes [1,4,7,9] et [-2,0,3,8] . Version it\u00e9rative : Compl\u00e9ter le code suivant : def fusion_it(T1, T2): taille_1 = len(T1) taille_2 = len(T2) T_trie = [] i1 = 0 i2 = 0 while (i1 < taille_1) and (...): if T1[i1] < T2[i2]: T_trie.append(...[i1]) i1 = ... else: T_trie.append(T2[...]) i2 = ... while i1 < taille_1: T_trie.append(...) i1 = ... while i2 < taille_2: T_trie.append(...) ... return T_trie Version r\u00e9cursive : On donne le squelette de la fonction, \u00e0 compl\u00e9ter : def fusion_rec(T1,T2): if ............ # premier cas de base, pour une valeur triviale de T1 return T2 elif ........... # deuxi\u00e8me cas de base, pour une valeur triviale de T2 return T1 elif T1[0] < T2[0]: return [.....] + fusion(........, .........) # on place le bon \u00e9l\u00e9ment en premier else: return [.....] + fusion(........, .........)","title":"B.1. La fusion"},{"location":"tle/seq2/diviser_regner/#b2-le-tri-complet","text":"La fonction permettant de trier compl\u00e8tement le tableau divise d'abord en deux le tableau initial, avant de fusionner les r\u00e9sultats des tris sur la premi\u00e8re, et la deuxi\u00e8me partie du tableau. Compl\u00e9ter le code suivant : def tri_fusion(tab): if .................... # cas de base return tab else: # on coupe le tableau en deux sous-tableaux t1 = [tab[i] for i in range(.......)] t2 = [tab[i] for i in range(.......)] return fusion(tri_fusion(.....), tri_fusion(.....)) Pour prendre les deux moiti\u00e9s du tableau, on aurait pu faire du slicing . Cette m\u00e9thode a aussi des d\u00e9savantages, il est utile de conna\u00eetre plusieurs m\u00e9thodes pour s\u00e9lectionner une partie d'un tableau.","title":"B.2. Le tri complet"},{"location":"tle/seq2/diviser_regner/#tp-la-recherche-dichotomique","text":"La recherche dichotomique d'un \u00e9l\u00e9ment e dans un tableau tri\u00e9 consiste : 1. A comparer e avec celui au milieu du tableau : - si e est plus grand, on continue la recherche dans la partie droite du tableau. - sinon, on continue la recherche dans la partie gauche du tableau. 2. On recommence en comparant e avec le milieu de la partie du tableau consid\u00e9r\u00e9e, et ainsi de suite. 3. L'algorithme termine lorsque e est trouv\u00e9, ou bien si l'on arrive sur le tableau vide. Appliquer l'algorithme pour rechercher 10 dans [1,6,10,15,17,20] . Rechercher 5 dans ce m\u00eame tableau. Compl\u00e9ter la version r\u00e9cursive suivante : def recherche_dichotomique_rec(t, elt, inf, sup): \"\"\"Version r\u00e9cursive de la recherche dichotomique d'un \u00e9l\u00e9ment dans un tableau tri\u00e9' Entr\u00e9es : t : liste Python (tableau) d'entiers ou de flottants tri\u00e9e elt : entier ou flottant recherch\u00e9 inf, sup : entiers correspondant respectivement \u00e0 l'indice inf\u00e9rieur et sup\u00e9rieur de la partie de t consid\u00e9r\u00e9e Sortie : entier, valant -1 si l'\u00e9lement n'est pas trouv\u00e9, l'indice de l'\u00e9l\u00e9ment trouv\u00e9 dans le tableau sinon \"\"\" mil = (sup+inf)//2 if sup<inf: return ... elif ... return mil elif elt > t[mil]: return recherche_dichotomique_rec(t, elt, ..., ...) else: return recherche_dichotomique_rec(t, elt, ..., ...) \u00c9crire une fonction recherche it\u00e9rative qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. N.B. : Cette version, du programme de 1\u00e8re, utilise une boucle while \u00e0 la place de l'appel r\u00e9cursif de la version pr\u00e9c\u00e9dente.","title":"TP : La recherche dichotomique"},{"location":"tle/seq2/piles/","text":"body { text-align: justify} S\u00e9quence 2 I. Les piles Cours A. D\u00e9finitions Qu'est-ce qu'une pile en informatique ? Une pile est une structure de donn\u00e9es, c'est-\u00e0-dire une mani\u00e8re de stocker, d'acc\u00e9der et de manipuler des donn\u00e9es. Elle fonctionne sur le principe du \"dernier entr\u00e9, premier sorti\", en anglais \"last in, first out\" (LIFO). Exemples de la vie quotidienne : les piles d'assiettes, de cr\u00eapes, de livres, etc. Exemples en informatique : - la fonction \"D\u00e9faire\" ou \"Undo\" d'un logiciel de bureautique, - la m\u00e9morisation des pages visit\u00e9es dans un navigateur web. Pour utiliser une telle structure dans un programme, il faut impl\u00e9menter des fonctions de base qui correspondent \u00e0 ce fonctionnement. On veut pouvoir : - construire une nouvelle pile (vide), - ajouter un \u00e9l\u00e9ment \u00e0 la pile : on empile un \u00e9l\u00e9ment, qui se retrouve au-dessus des autres, - enlever un \u00e9l\u00e9ment \u00e0 la pile : on d\u00e9pile un \u00e9l\u00e9ment, le dernier ajout\u00e9, - tester si la pile est vide ou non. B. Impl\u00e9mentation On propose une impl\u00e9mentation de pile, utilisant la POO (ce qui n'\u00e9tait pas obligatoire !) . class Pile: \"\"\" D\u00e9finition d'une pile avec une liste Python \"\"\" def __init__(self): \"\"\"Initialise une pile vide\"\"\" self.L = [] def vide(self): \"\"\"Teste si la pile est vide\"\"\" return self.L == [] def depiler(self): \"\"\"d\u00e9pile, c'est-\u00e0-dire enl\u00e8ve le dernier \u00e9l\u00e9ment de la pile\"\"\" assert(not(self.vide())) # pr\u00e9condition return self.L.pop() def empiler(self, x): \"\"\"Empile, c'est-\u00e0-dire ajoute un \u00e9l\u00e9ment \u00e0 la fin de la pile\"\"\" self.L.append(x) Ajouter la description des diff\u00e9rentes m\u00e9thodes (\u00e0 associer aux fonctions de base d\u00e9crite ci-dessus) . Ajouter une assertion qui v\u00e9rifiera une pr\u00e9condition sur les donn\u00e9es d'entr\u00e9e n\u00e9cessaire au bon fonctionnement de depiler . Cr\u00e9er un objet de la classe Pile et lui ajouter successivement les entiers 0, 1 et 2. p = Pile() p.empiler(0) p.empiler(1) p.empiler(2) Enlever le dernier \u00e9l\u00e9ment de la pile. Avant de le faire, il faudra v\u00e9rifier qu'elle n'est pas vide. if not(p.vide()): p.depiler() Exercices Exercice 1 : sur un logiciel de traitement de texte (sur feuille) Un utilisateur de traitement de texte tape successivement les lettres suivantes : \u2018v\u2019, \u2018i\u2019, \u2018v\u2019, \u2018e\u2019, \u2018n\u2019 (\u00e9tape 1). Il s\u2019arr\u00eate et clique une fois sur \u00ab undo \u00bb (\u00e9tape 2). Il continue : \u2018 \u2019 (espace), \u2018l\u2019, \u2018e\u2019, \u2018s\u2019, \u2018 \u2018, \u2018m\u2019, \u2018a\u2019, \u2018t\u2019, \u2018h\u2019, \u2018s\u2019 (\u00e9tape 3). Pris d\u2019un doute, il change d\u2019avis et clique 9 fois sur \u00ab undo \u00bb (\u00e9tape 4). Il rectifie en tapant : \u2018n\u2019, \u2018s\u2019, \u2018i\u2019 (\u00e9tape 5). Dessiner les \u00e9tapes 1 \u00e0 5 d\u00e9crites ci-dessus en repr\u00e9sentant le contenu de la pile stockant les caract\u00e8res au fur et \u00e0 mesure. Exercice 2 : des cr\u00eapes trop go\u00fbtues (sur feuille d'abord) Erwan invite des amis \u00e0 manger des cr\u00eapes. Il les place les unes sur les autres sur une assiette. Il commence \u00e0 en manger une pour go\u00fbter le r\u00e9sultat, et la trouve tellement bonne qu\u2019il ne peut s\u2019emp\u00eacher de manger les autres\u2026 jusqu\u2019\u00e0 la derni\u00e8re. En utilisant la classe Pile du cours, \u00e9crire une fonction vide_crepes qui prend en param\u00e8tre une pile de cr\u00eapes ( pile_crepes ) et la vide compl\u00e8tement. Cette fonction ne renvoie rien, mais l\u2019instruction pile_crepe.vide() doit retourner True apr\u00e8s son ex\u00e9cution. Comment cela se fait-il que l'on puisse modifier une variable dans une fonction, et r\u00e9cup\u00e9rer cette valeur modifi\u00e9e \u00e0 l'ext\u00e9rieur ? C'est une particularit\u00e9 de Python, cela fonctionne pour les listes Python (et autres types compos\u00e9s), mais pas pour des variables de type int , str , bool . Exercice 3 : les assiettes de la grand-m\u00e8re (sur feuille d'abord) Marion est \u00e0 la recherche des assiettes qui lui viennent de sa grand-m\u00e8re, qui sont rang\u00e9es en bas d\u2019une pile d\u2019autres assiettes. Il faut qu\u2019elle d\u00e9pile cette derni\u00e8re, jusqu\u2019\u00e0 trouver la premi\u00e8re assiette de sa grand-m\u00e8re. Elle se retrouve finalement avec deux piles d\u2019assiettes. En utilisant la classe Pile du cours, \u00e9crire une fonction separe_assiettes(pile_assiettes, elt) qui d\u00e9pile pile_assiettes jusqu\u2019\u00e0 rencontrer l\u2019assiette elt et empile les assiettes retir\u00e9es dans une autre pile. La fonction retourne pile_assiettes modifi\u00e9e, et la 2\u00e8me pile. Si les assiettes recherch\u00e9es ne sont pas trouv\u00e9es, la fonction ne retourne rien. Exercice 4 : expressions bien parenth\u00e9s\u00e9es (sur ordinateur) Nous voulons \u00e9crire une fonction qui contr\u00f4le si une expression math\u00e9matique, donn\u00e9e sous forme d\u2019une cha\u00eene de caract\u00e8res, est bien parenth\u00e9s\u00e9e : c\u2019est- \u00e0-dire s\u2019il y a autant de parenth\u00e8ses ouvrantes que de fermantes, et qu\u2019elles sont bien plac\u00e9es. Exemple : (..(..)..) est bien parenth\u00e9s\u00e9e. (...(..(..)...) ne l\u2019est pas. Voici l\u2019algorithme utilis\u00e9 : Notre expression est stock\u00e9e dans une variable 'exp' La sortie est stock\u00e9e dans une variable 'parenthesee' On cr\u00e9e une pile 'p' Pour i variant de 0 \u00e0 la longueur de exp-1 Si \u00e9l\u00e9ment 'i' de 'exp' vaut \"(\" On empile \"(\" dans 'p' Sinon si \u00e9l\u00e9ment 'i' de exp vaut \")\" si 'p' non vide on d\u00e9pile 'p' sinon 'parenthesee' vaut \"Faux\" 'parenthesee' vaut : 'p' est-elle vide ? Traduire ce pseudo-code en code Python. Utiliser la structure de pile du cours. Tester le code sur les expressions suivantes : \\(((2+64)*2^8+5)\\) \\(10+((75-64)*4\\) Pour aller plus loin... Faire en sorte que le programme tienne \u00e9galement compte des \"[\" en plus des \"(\".","title":"I. Les piles"},{"location":"tle/seq2/piles/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"tle/seq2/piles/#i-les-piles","text":"","title":"I. Les piles"},{"location":"tle/seq2/piles/#cours","text":"","title":"Cours"},{"location":"tle/seq2/piles/#a-definitions","text":"Qu'est-ce qu'une pile en informatique ? Une pile est une structure de donn\u00e9es, c'est-\u00e0-dire une mani\u00e8re de stocker, d'acc\u00e9der et de manipuler des donn\u00e9es. Elle fonctionne sur le principe du \"dernier entr\u00e9, premier sorti\", en anglais \"last in, first out\" (LIFO). Exemples de la vie quotidienne : les piles d'assiettes, de cr\u00eapes, de livres, etc. Exemples en informatique : - la fonction \"D\u00e9faire\" ou \"Undo\" d'un logiciel de bureautique, - la m\u00e9morisation des pages visit\u00e9es dans un navigateur web. Pour utiliser une telle structure dans un programme, il faut impl\u00e9menter des fonctions de base qui correspondent \u00e0 ce fonctionnement. On veut pouvoir : - construire une nouvelle pile (vide), - ajouter un \u00e9l\u00e9ment \u00e0 la pile : on empile un \u00e9l\u00e9ment, qui se retrouve au-dessus des autres, - enlever un \u00e9l\u00e9ment \u00e0 la pile : on d\u00e9pile un \u00e9l\u00e9ment, le dernier ajout\u00e9, - tester si la pile est vide ou non.","title":"A. D\u00e9finitions"},{"location":"tle/seq2/piles/#b-implementation","text":"On propose une impl\u00e9mentation de pile, utilisant la POO (ce qui n'\u00e9tait pas obligatoire !) . class Pile: \"\"\" D\u00e9finition d'une pile avec une liste Python \"\"\" def __init__(self): \"\"\"Initialise une pile vide\"\"\" self.L = [] def vide(self): \"\"\"Teste si la pile est vide\"\"\" return self.L == [] def depiler(self): \"\"\"d\u00e9pile, c'est-\u00e0-dire enl\u00e8ve le dernier \u00e9l\u00e9ment de la pile\"\"\" assert(not(self.vide())) # pr\u00e9condition return self.L.pop() def empiler(self, x): \"\"\"Empile, c'est-\u00e0-dire ajoute un \u00e9l\u00e9ment \u00e0 la fin de la pile\"\"\" self.L.append(x) Ajouter la description des diff\u00e9rentes m\u00e9thodes (\u00e0 associer aux fonctions de base d\u00e9crite ci-dessus) . Ajouter une assertion qui v\u00e9rifiera une pr\u00e9condition sur les donn\u00e9es d'entr\u00e9e n\u00e9cessaire au bon fonctionnement de depiler . Cr\u00e9er un objet de la classe Pile et lui ajouter successivement les entiers 0, 1 et 2. p = Pile() p.empiler(0) p.empiler(1) p.empiler(2) Enlever le dernier \u00e9l\u00e9ment de la pile. Avant de le faire, il faudra v\u00e9rifier qu'elle n'est pas vide. if not(p.vide()): p.depiler()","title":"B. Impl\u00e9mentation"},{"location":"tle/seq2/piles/#exercices","text":"","title":"Exercices"},{"location":"tle/seq2/piles/#exercice-1-sur-un-logiciel-de-traitement-de-texte-sur-feuille","text":"Un utilisateur de traitement de texte tape successivement les lettres suivantes : \u2018v\u2019, \u2018i\u2019, \u2018v\u2019, \u2018e\u2019, \u2018n\u2019 (\u00e9tape 1). Il s\u2019arr\u00eate et clique une fois sur \u00ab undo \u00bb (\u00e9tape 2). Il continue : \u2018 \u2019 (espace), \u2018l\u2019, \u2018e\u2019, \u2018s\u2019, \u2018 \u2018, \u2018m\u2019, \u2018a\u2019, \u2018t\u2019, \u2018h\u2019, \u2018s\u2019 (\u00e9tape 3). Pris d\u2019un doute, il change d\u2019avis et clique 9 fois sur \u00ab undo \u00bb (\u00e9tape 4). Il rectifie en tapant : \u2018n\u2019, \u2018s\u2019, \u2018i\u2019 (\u00e9tape 5). Dessiner les \u00e9tapes 1 \u00e0 5 d\u00e9crites ci-dessus en repr\u00e9sentant le contenu de la pile stockant les caract\u00e8res au fur et \u00e0 mesure.","title":"Exercice 1 : sur un logiciel de traitement de texte (sur feuille)"},{"location":"tle/seq2/piles/#exercice-2-des-crepes-trop-goutues-sur-feuille-dabord","text":"Erwan invite des amis \u00e0 manger des cr\u00eapes. Il les place les unes sur les autres sur une assiette. Il commence \u00e0 en manger une pour go\u00fbter le r\u00e9sultat, et la trouve tellement bonne qu\u2019il ne peut s\u2019emp\u00eacher de manger les autres\u2026 jusqu\u2019\u00e0 la derni\u00e8re. En utilisant la classe Pile du cours, \u00e9crire une fonction vide_crepes qui prend en param\u00e8tre une pile de cr\u00eapes ( pile_crepes ) et la vide compl\u00e8tement. Cette fonction ne renvoie rien, mais l\u2019instruction pile_crepe.vide() doit retourner True apr\u00e8s son ex\u00e9cution. Comment cela se fait-il que l'on puisse modifier une variable dans une fonction, et r\u00e9cup\u00e9rer cette valeur modifi\u00e9e \u00e0 l'ext\u00e9rieur ? C'est une particularit\u00e9 de Python, cela fonctionne pour les listes Python (et autres types compos\u00e9s), mais pas pour des variables de type int , str , bool .","title":"Exercice 2 : des cr\u00eapes trop go\u00fbtues (sur feuille d'abord)"},{"location":"tle/seq2/piles/#exercice-3-les-assiettes-de-la-grand-mere-sur-feuille-dabord","text":"Marion est \u00e0 la recherche des assiettes qui lui viennent de sa grand-m\u00e8re, qui sont rang\u00e9es en bas d\u2019une pile d\u2019autres assiettes. Il faut qu\u2019elle d\u00e9pile cette derni\u00e8re, jusqu\u2019\u00e0 trouver la premi\u00e8re assiette de sa grand-m\u00e8re. Elle se retrouve finalement avec deux piles d\u2019assiettes. En utilisant la classe Pile du cours, \u00e9crire une fonction separe_assiettes(pile_assiettes, elt) qui d\u00e9pile pile_assiettes jusqu\u2019\u00e0 rencontrer l\u2019assiette elt et empile les assiettes retir\u00e9es dans une autre pile. La fonction retourne pile_assiettes modifi\u00e9e, et la 2\u00e8me pile. Si les assiettes recherch\u00e9es ne sont pas trouv\u00e9es, la fonction ne retourne rien.","title":"Exercice 3 : les assiettes de la grand-m\u00e8re (sur feuille d'abord)"},{"location":"tle/seq2/piles/#exercice-4-expressions-bien-parenthesees-sur-ordinateur","text":"Nous voulons \u00e9crire une fonction qui contr\u00f4le si une expression math\u00e9matique, donn\u00e9e sous forme d\u2019une cha\u00eene de caract\u00e8res, est bien parenth\u00e9s\u00e9e : c\u2019est- \u00e0-dire s\u2019il y a autant de parenth\u00e8ses ouvrantes que de fermantes, et qu\u2019elles sont bien plac\u00e9es. Exemple : (..(..)..) est bien parenth\u00e9s\u00e9e. (...(..(..)...) ne l\u2019est pas. Voici l\u2019algorithme utilis\u00e9 : Notre expression est stock\u00e9e dans une variable 'exp' La sortie est stock\u00e9e dans une variable 'parenthesee' On cr\u00e9e une pile 'p' Pour i variant de 0 \u00e0 la longueur de exp-1 Si \u00e9l\u00e9ment 'i' de 'exp' vaut \"(\" On empile \"(\" dans 'p' Sinon si \u00e9l\u00e9ment 'i' de exp vaut \")\" si 'p' non vide on d\u00e9pile 'p' sinon 'parenthesee' vaut \"Faux\" 'parenthesee' vaut : 'p' est-elle vide ? Traduire ce pseudo-code en code Python. Utiliser la structure de pile du cours. Tester le code sur les expressions suivantes : \\(((2+64)*2^8+5)\\) \\(10+((75-64)*4\\) Pour aller plus loin... Faire en sorte que le programme tienne \u00e9galement compte des \"[\" en plus des \"(\".","title":"Exercice 4 : expressions bien parenth\u00e9s\u00e9es (sur ordinateur)"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/","text":"body { text-align: justify} S\u00e9quence 2 II. La r\u00e9cursivit\u00e9 Cours Introduction Les poup\u00e9es russes ou matriochkas sont des s\u00e9ries de poup\u00e9es de tailles d\u00e9croissantes plac\u00e9es les unes \u00e0 l'int\u00e9rieur des autres. Elles sont toutes identiques, ne diff\u00e9rant que par leur taille. La derni\u00e8re est diff\u00e9rente, dans le sens o\u00f9 elle ne contient pas d'autre poup\u00e9e \u00e0 l'int\u00e9rieur. Une matriochka est une structure r\u00e9cursive : c'est une matriochka pleine, OU bien une matriochka contenant une autre matriochka plus petite. A. D\u00e9finition Une fonction r\u00e9cursive est une fonction qui s\u2019appelle elle-m\u00eame. Pour \u00e9viter que cette fonction s\u2019appelle \u00e0 l\u2019infini, il faut : - qu\u2019elle ait un cas de base (c'est le cas le plus simple \u00e0 r\u00e9soudre), aussi appel\u00e9 condition d'arr\u00eat (dans laquelle il n'y a plus d'appel r\u00e9cursif donc la fonction s'arr\u00eate), - qu\u2019elle se ram\u00e8ne vers ce cas de base, donc qu'il y ait un appel \u00e0 elle-m\u00eame sur un plus petit probl\u00e8me que le probl\u00e8me initial (un entier plus petit, une cha\u00eene de caract\u00e8re plus courte, etc). B. Fonctionnement d'une pile d'ex\u00e9cution B.1. Cas g\u00e9n\u00e9ral Lors de l\u2019appel d\u2019une fonction, le syst\u00e8me sauvegarde diff\u00e9rents param\u00e8tres comme ses arguments et les variables utilis\u00e9es \u00e0 l\u2019int\u00e9rieur de celle-ci. C\u2019est son contexte d\u2019ex\u00e9cution . Cela permet d\u2019interrompre l\u2019ex\u00e9cution d\u2019une fonction lorsque celle-ci en appelle d\u2019autre, et de reprendre son ex\u00e9cution ensuite. Exemple : def h(x): return x + 1 def g(x): return h(x) * 2 def f(x): return g(x) + 1 B.2. Cas r\u00e9cursif Une fonction r\u00e9cursive est une fonction dans laquelle il y a des appels de fonctions, avec la particularit\u00e9 qu'il s'agit de la m\u00eame fonction. La m\u00eame chose se produit donc : une pile d\u2019ex\u00e9cution est utilis\u00e9e pour stocker le contexte d\u2019ex\u00e9cution de ses diff\u00e9rents appels. Prenons l'exemple classique du calcul de \\(2^n\\) : def puissance(n) : if n == 0 : return 1 else : return 2*puissance(n-1) Ecrire le calcul de puissance(3) : puissance(3) = 2 * puissance(2) puissance(2) = 2 * puissance(1) puissance(1) = 2 * puissance(0) puissance(0) = 1 puissance(3) = 2 * 2 * 2 * 1 = 8 Le sch\u00e9ma suivant explique le processus en terme de pile d\u2019ex\u00e9cution : B.3. Cas limite La pile d\u2019ex\u00e9cution a une taille maximale. Lorsque la pile d\u00e9borde - \"stack overflow\" - (par d\u00e9faut au bout de 1000 appels), Python renvoie le message suivant : RecursionError: maximum recursion depth exceeded while calling a Python object C. R\u00e9cursivit\u00e9 et paradigmes Le paradigme r\u00e9cursif s\u2019oppose g\u00e9n\u00e9ralement au paradigme it\u00e9ratif . Ce dernier est une sous-cat\u00e9gorie du paradigme imp\u00e9ratif et fait r\u00e9f\u00e9rence \u00e0 l\u2019utilisation de boucles. Avec la r\u00e9cursivit\u00e9, on peut se passer de boucles. C\u2019est cette m\u00e9thode de programmation qui les remplace lorsque l\u2019on programme en utilisant le paradigme fonctionnel . Exercices Les exercices traitent d'abord d'algorithmes qui manipulent des entiers , puis des cha\u00eenes de caract\u00e8res (et des listes en bonus). Exercice 1 : factorielle La fonction factorielle, appliqu\u00e9e \u00e0 un entier \\(n\\) est not\u00e9e \\(!n\\) et est d\u00e9finie de la mani\u00e8re suivante : - \\(!0 = 1\\) - \\(!n = 1*2*...*(n-1)*n\\) Exprimer \\(!n\\) en fonction de \\(!(n-1)\\) . En d\u00e9duire une fonction factorielle(n) calculant la valeur de !n pour tout entier n . V\u00e9rifier que factorielle(5) renvoie bien la valeur 120 et factorielle(7) la valeur 5040 . Dessiner la pile d'ex\u00e9cution pour l'appel de factorielle(4) . V\u00e9rifier votre travail en visualisant l'ex\u00e9cution de votre code avec https://pythontutor.com/visualize.html Exercice 2 : la suite de Fibonacci La suite de Fibonacci est d\u00e9finie comme suit : - \\(u_0 = 0\\) et \\(u_1 = 1\\) - \\(u_n=u_{n-1}+u_{n-2}\\) 1. \u00c9crire une fonction r\u00e9cursive fib_rec(n) qui donne le n i\u00e8me terme de la suite de Fibonacci. 2. Repr\u00e9senter les appels r\u00e9cursifs de fib_rec(5) sous la forme d\u2019une structure hi\u00e9rarchique, puis sous la forme d\u2019une pile. Exercice 3 : palindromes Un palindrome est un mot pouvant se lire \u00e0 l'endroit comme \u00e0 l'envers, comme \"\u00e9t\u00e9\" ou \"radar\". On veut \u00e9crire une fonction palindrome prenant en entr\u00e9e une cha\u00eene de caract\u00e8re mot et renvoyant un bool\u00e9en indiquant si ce mot est un palindrome ou non. Les cas de base sont les cas o\u00f9 mot est de longueur 0 ou 1. Que doit renvoyer la fonction dans ces cas ? Dans tous les autres cas, mot est un palindrome si : la premi\u00e8re et la derni\u00e8re lettre du mot sont identiques, le reste du mot (sans la premi\u00e8re et la derni\u00e8re lettre) est un palindrome. Sur quelle valeur l'appel r\u00e9cursif se fait-il ? Ecrire la fonction palindrome incluant ces diff\u00e9rents cas. Pour aller plus loin... Exercice 4 : somme d'une liste Une fonction r\u00e9cursive appliquant un traitement sur une liste fonctionne de la m\u00eame mani\u00e8re qu'avec un entier : il faut, \u00e0 chaque nouvel appel, r\u00e9duire le probl\u00e8me. C'est-\u00e0-dire ici, r\u00e9duire la liste initiale (par exemple consid\u00e9rer la m\u00eame liste \u00e0 laquelle on a enlev\u00e9 le premier \u00e9l\u00e9ment). Ecrire une fonction it\u00e9rative (utilisant une boucle) permettant de calculer la somme des \u00e9l\u00e9ments d'une liste de nombres somme_it(liste) . Pour quelle valeur de la liste est-il le plus facile de faire ce calcul, et que vaut-il dans ce cas ? (\u00e9tat trivial) Pour prendre une partie d'une liste Python, on peut faire ce qu'on appelle du slicing , c'est-\u00e0-dire un d\u00e9coupage de la liste entre deux indices : pour une liste l , on peut choisir de consid\u00e9rer l[i:j] qui prendra les \u00e9l\u00e9ments de i \u00e0 j-1 de l . En d\u00e9duire comment prendre tous les \u00e9l\u00e9ments d'une liste sauf le premier. En d\u00e9duire l'appel r\u00e9cursif de la fonction somme_rec qui sera fait pour faire le calcul de la somme d'une liste de mani\u00e8re r\u00e9cursive. Ecrire la fonction r\u00e9cursive somme_rec(liste) . TD : Les tours de Hano\u00ef Introduction Le jeu des tours de Hano\u00ef consiste \u00e0 d\u00e9placer une pile de disques, de taille diff\u00e9rente, d'une tige de d\u00e9part (\u00e0 gauche) \u00e0 une tige d'arriv\u00e9e (tout \u00e0 droite) en respectant la r\u00e8gle suivante : un disque ne peut \u00eatre plac\u00e9 sur un autre disque de plus petite taille . A. Du cas particulier au cas g\u00e9n\u00e9ral Comment r\u00e9soudre le probl\u00e8me pour 2 disques ? (le repr\u00e9senter sur le sch\u00e9ma ci-dessous) R\u00e9soudre le probl\u00e8me pour 3, 4 et 5 disques gr\u00e2ce \u00e0 cette simulation : http://championmath.free.fr/tourhanoi.htm On consid\u00e8re une pile de n disques, et on suppose que l'on sait r\u00e9soudre le probl\u00e8me pour n-1 diques . Repr\u00e9senter les \u00e9tapes permettant de d\u00e9placer le n \u00e8me disque et la pile de n-1 disques (qui se d\u00e9place en entier, on suppose qu'on sait le faire) , de mani\u00e8re \u00e0 r\u00e9soudre le probl\u00e8me : R\u00e9capituler les trois \u00e9tapes de r\u00e9solution du probl\u00e8me : Etape 1 : Etape 2 : Etape 3 : B. Algorithme Pour r\u00e9soudre le probl\u00e8me pour n disques, on fait appel, 2 fois, \u00e0 la r\u00e9solution du probl\u00e8me pour n-1 disques. Nous allons donc utiliser un algorithme r\u00e9cursif. On propose le pseudo-code suivant : fonction Hanoi(n, dep, inter, arr) ''' Affiche les d\u00e9placements pour r\u00e9soudre le probl\u00e8me de Hano\u00ef pour n disques Entr\u00e9es : n : entier repr\u00e9sentant le nombre de disques \u00e0 d\u00e9placer dep, inter, arr : caract\u00e8res indiquant les sommets de d\u00e9part, interm\u00e9diaire et d'arriv\u00e9e ''' Si n est \u00e9gal \u00e0 0 retourner Rien Sinon Hanoi(.........................) afficher le d\u00e9placement depuis dep jusqu\u2019\u00e0 arr Hanoi(.........................) Compl\u00e9ter le pseudo-code avec les bons param\u00e8tres pour les appels r\u00e9cursifs \u00e0 la fonction Hanoi . C. Impl\u00e9mentation Ecrire l'impl\u00e9mentation en Python de cet algorithme ci-dessous : N.B.: Pour l'affichage, on peut utiliser une instruction du type : print(\"D\u00e9placer le disque \", str(n), \"de la tige \", dep, \" vers la tige \", arr) Pour visualiser ce qu'il se passe, compl\u00e9ter le fichier Python fourni (sur l'ENT) . TP : Dessiner des fractales Une fractale est un objet qui appara\u00eet identique \u00e0 diff\u00e9rentes \u00e9chelles : en \"zoomant\" sur une partie de la figure, on retrouve la figure initiale. On peut repr\u00e9senter une version approch\u00e9e des fractales avec des programmes r\u00e9cursifs, dont on d\u00e9fini le niveau de r\u00e9cursion (donc le niveau de d\u00e9tails de la figure). 1. Des bulles Le code suivant (accessible sur l'ENT) permet de dessiner une figure avec des bulles. Il utilise la biblioth\u00e8que turtle dont des \u00e9l\u00e9ments de documentation sont donn\u00e9s dans le fichier. from turtle import * def dessine_cercle(x, y, r): up() goto(x,y-r) down() circle(r) return None def bubble(n, x, y, r): if n == 0: return None else: dessine_cercle(x,y,r) bubble(n-1, x+3/2*r, y, r/2) bubble(n-1, x, y-3/2*r, r/2) return None bubble(4,-100,100,50) done() Ex\u00e9cuter le code. Faire varier la valeur de n pour augmenter le niveau de d\u00e9tails de la figure. Identifier les appels r\u00e9cursifs de la fonction bubble . Quel param\u00e8tre permet de r\u00e9duire la taille des bulles au fur et \u00e0 mesure ? Quels param\u00e8tres changent la position de la tortue ? La variation de quel param\u00e8tre nous assure que l'algorithme va se terminer ? 2. Le flocon de von Koch Le flocon de Von Koch est une des premi\u00e8res courbes fractales \u00e0 avoir \u00e9t\u00e9 d\u00e9crite. Elle a \u00e9t\u00e9 invent\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Helge von Koch. Voici une partie de ce flocon : 2.A. Principe On commence par un segment de longueur a . On coupe ce segment en 3 parties \u00e9gales. On remplace le segment central par un triangle \u00e9quilat\u00e9ral de c\u00f4t\u00e9 a/3 . Chaque segment de longueur a/3 est lui-m\u00eame d\u00e9coup\u00e9 en 3 parties \u00e9gales (chacune de longueur a/9 ). On remplace chaque partie centrale par un triangle \u00e9quilat\u00e9ral de c\u00f4t\u00e9 a/9 . etc. 2.B. Algorithme Nous allons utiliser un algorithme similaire \u00e0 celui qui permet de tracer le motif avec les bulles pour dessiner ce flocon. Compl\u00e9ter l'algorithme propos\u00e9 : fonction fragment_flocon(n, cote): ENTREES : n : entier indiquant le nombre d\u2019it\u00e9ration \u00e0 faire cote : la longueur du segment initial Si n est \u00e9gal \u00e0 0 alors On trace le segment de longueur cote Sinon On appelle la fonction fragment_flocon avec les param\u00e8tres __________ On tourne de _____ degr\u00e9s sur la _______________ ___________________________________________________ __________________________________________ ___________________________________________________ __________________________________________ ___________________________________________________ 2.C. Impl\u00e9mentation Impl\u00e9menter l'algorithme en Python permettant de dessiner une partie du flocon. Ecrire la fonction flocon dessinant le flocon en entier.","title":"II. La r\u00e9cursivit\u00e9"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#sequence-2","text":"","title":"S\u00e9quence 2"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#ii-la-recursivite","text":"","title":"II. La r\u00e9cursivit\u00e9"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#cours","text":"","title":"Cours"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#introduction","text":"Les poup\u00e9es russes ou matriochkas sont des s\u00e9ries de poup\u00e9es de tailles d\u00e9croissantes plac\u00e9es les unes \u00e0 l'int\u00e9rieur des autres. Elles sont toutes identiques, ne diff\u00e9rant que par leur taille. La derni\u00e8re est diff\u00e9rente, dans le sens o\u00f9 elle ne contient pas d'autre poup\u00e9e \u00e0 l'int\u00e9rieur. Une matriochka est une structure r\u00e9cursive : c'est une matriochka pleine, OU bien une matriochka contenant une autre matriochka plus petite.","title":"Introduction"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#a-definition","text":"Une fonction r\u00e9cursive est une fonction qui s\u2019appelle elle-m\u00eame. Pour \u00e9viter que cette fonction s\u2019appelle \u00e0 l\u2019infini, il faut : - qu\u2019elle ait un cas de base (c'est le cas le plus simple \u00e0 r\u00e9soudre), aussi appel\u00e9 condition d'arr\u00eat (dans laquelle il n'y a plus d'appel r\u00e9cursif donc la fonction s'arr\u00eate), - qu\u2019elle se ram\u00e8ne vers ce cas de base, donc qu'il y ait un appel \u00e0 elle-m\u00eame sur un plus petit probl\u00e8me que le probl\u00e8me initial (un entier plus petit, une cha\u00eene de caract\u00e8re plus courte, etc).","title":"A. D\u00e9finition"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#b-fonctionnement-dune-pile-dexecution","text":"","title":"B. Fonctionnement d'une pile d'ex\u00e9cution"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#b1-cas-general","text":"Lors de l\u2019appel d\u2019une fonction, le syst\u00e8me sauvegarde diff\u00e9rents param\u00e8tres comme ses arguments et les variables utilis\u00e9es \u00e0 l\u2019int\u00e9rieur de celle-ci. C\u2019est son contexte d\u2019ex\u00e9cution . Cela permet d\u2019interrompre l\u2019ex\u00e9cution d\u2019une fonction lorsque celle-ci en appelle d\u2019autre, et de reprendre son ex\u00e9cution ensuite. Exemple : def h(x): return x + 1 def g(x): return h(x) * 2 def f(x): return g(x) + 1","title":"B.1. Cas g\u00e9n\u00e9ral"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#b2-cas-recursif","text":"Une fonction r\u00e9cursive est une fonction dans laquelle il y a des appels de fonctions, avec la particularit\u00e9 qu'il s'agit de la m\u00eame fonction. La m\u00eame chose se produit donc : une pile d\u2019ex\u00e9cution est utilis\u00e9e pour stocker le contexte d\u2019ex\u00e9cution de ses diff\u00e9rents appels. Prenons l'exemple classique du calcul de \\(2^n\\) : def puissance(n) : if n == 0 : return 1 else : return 2*puissance(n-1) Ecrire le calcul de puissance(3) : puissance(3) = 2 * puissance(2) puissance(2) = 2 * puissance(1) puissance(1) = 2 * puissance(0) puissance(0) = 1 puissance(3) = 2 * 2 * 2 * 1 = 8 Le sch\u00e9ma suivant explique le processus en terme de pile d\u2019ex\u00e9cution :","title":"B.2. Cas r\u00e9cursif"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#b3-cas-limite","text":"La pile d\u2019ex\u00e9cution a une taille maximale. Lorsque la pile d\u00e9borde - \"stack overflow\" - (par d\u00e9faut au bout de 1000 appels), Python renvoie le message suivant : RecursionError: maximum recursion depth exceeded while calling a Python object","title":"B.3. Cas limite"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#c-recursivite-et-paradigmes","text":"Le paradigme r\u00e9cursif s\u2019oppose g\u00e9n\u00e9ralement au paradigme it\u00e9ratif . Ce dernier est une sous-cat\u00e9gorie du paradigme imp\u00e9ratif et fait r\u00e9f\u00e9rence \u00e0 l\u2019utilisation de boucles. Avec la r\u00e9cursivit\u00e9, on peut se passer de boucles. C\u2019est cette m\u00e9thode de programmation qui les remplace lorsque l\u2019on programme en utilisant le paradigme fonctionnel .","title":"C. R\u00e9cursivit\u00e9 et paradigmes"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#exercices","text":"Les exercices traitent d'abord d'algorithmes qui manipulent des entiers , puis des cha\u00eenes de caract\u00e8res (et des listes en bonus).","title":"Exercices"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#exercice-1-factorielle","text":"La fonction factorielle, appliqu\u00e9e \u00e0 un entier \\(n\\) est not\u00e9e \\(!n\\) et est d\u00e9finie de la mani\u00e8re suivante : - \\(!0 = 1\\) - \\(!n = 1*2*...*(n-1)*n\\) Exprimer \\(!n\\) en fonction de \\(!(n-1)\\) . En d\u00e9duire une fonction factorielle(n) calculant la valeur de !n pour tout entier n . V\u00e9rifier que factorielle(5) renvoie bien la valeur 120 et factorielle(7) la valeur 5040 . Dessiner la pile d'ex\u00e9cution pour l'appel de factorielle(4) . V\u00e9rifier votre travail en visualisant l'ex\u00e9cution de votre code avec https://pythontutor.com/visualize.html","title":"Exercice 1 : factorielle"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#exercice-2-la-suite-de-fibonacci","text":"La suite de Fibonacci est d\u00e9finie comme suit : - \\(u_0 = 0\\) et \\(u_1 = 1\\) - \\(u_n=u_{n-1}+u_{n-2}\\) 1. \u00c9crire une fonction r\u00e9cursive fib_rec(n) qui donne le n i\u00e8me terme de la suite de Fibonacci. 2. Repr\u00e9senter les appels r\u00e9cursifs de fib_rec(5) sous la forme d\u2019une structure hi\u00e9rarchique, puis sous la forme d\u2019une pile.","title":"Exercice 2 : la suite de Fibonacci"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#exercice-3-palindromes","text":"Un palindrome est un mot pouvant se lire \u00e0 l'endroit comme \u00e0 l'envers, comme \"\u00e9t\u00e9\" ou \"radar\". On veut \u00e9crire une fonction palindrome prenant en entr\u00e9e une cha\u00eene de caract\u00e8re mot et renvoyant un bool\u00e9en indiquant si ce mot est un palindrome ou non. Les cas de base sont les cas o\u00f9 mot est de longueur 0 ou 1. Que doit renvoyer la fonction dans ces cas ? Dans tous les autres cas, mot est un palindrome si : la premi\u00e8re et la derni\u00e8re lettre du mot sont identiques, le reste du mot (sans la premi\u00e8re et la derni\u00e8re lettre) est un palindrome. Sur quelle valeur l'appel r\u00e9cursif se fait-il ? Ecrire la fonction palindrome incluant ces diff\u00e9rents cas.","title":"Exercice 3 : palindromes"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#pour-aller-plus-loin","text":"","title":"Pour aller plus loin..."},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#exercice-4-somme-dune-liste","text":"Une fonction r\u00e9cursive appliquant un traitement sur une liste fonctionne de la m\u00eame mani\u00e8re qu'avec un entier : il faut, \u00e0 chaque nouvel appel, r\u00e9duire le probl\u00e8me. C'est-\u00e0-dire ici, r\u00e9duire la liste initiale (par exemple consid\u00e9rer la m\u00eame liste \u00e0 laquelle on a enlev\u00e9 le premier \u00e9l\u00e9ment). Ecrire une fonction it\u00e9rative (utilisant une boucle) permettant de calculer la somme des \u00e9l\u00e9ments d'une liste de nombres somme_it(liste) . Pour quelle valeur de la liste est-il le plus facile de faire ce calcul, et que vaut-il dans ce cas ? (\u00e9tat trivial) Pour prendre une partie d'une liste Python, on peut faire ce qu'on appelle du slicing , c'est-\u00e0-dire un d\u00e9coupage de la liste entre deux indices : pour une liste l , on peut choisir de consid\u00e9rer l[i:j] qui prendra les \u00e9l\u00e9ments de i \u00e0 j-1 de l . En d\u00e9duire comment prendre tous les \u00e9l\u00e9ments d'une liste sauf le premier. En d\u00e9duire l'appel r\u00e9cursif de la fonction somme_rec qui sera fait pour faire le calcul de la somme d'une liste de mani\u00e8re r\u00e9cursive. Ecrire la fonction r\u00e9cursive somme_rec(liste) .","title":"Exercice 4 : somme d'une liste"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#td-les-tours-de-hanoi","text":"","title":"TD : Les tours de Hano\u00ef"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#introduction_1","text":"Le jeu des tours de Hano\u00ef consiste \u00e0 d\u00e9placer une pile de disques, de taille diff\u00e9rente, d'une tige de d\u00e9part (\u00e0 gauche) \u00e0 une tige d'arriv\u00e9e (tout \u00e0 droite) en respectant la r\u00e8gle suivante : un disque ne peut \u00eatre plac\u00e9 sur un autre disque de plus petite taille .","title":"Introduction"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#a-du-cas-particulier-au-cas-general","text":"Comment r\u00e9soudre le probl\u00e8me pour 2 disques ? (le repr\u00e9senter sur le sch\u00e9ma ci-dessous) R\u00e9soudre le probl\u00e8me pour 3, 4 et 5 disques gr\u00e2ce \u00e0 cette simulation : http://championmath.free.fr/tourhanoi.htm On consid\u00e8re une pile de n disques, et on suppose que l'on sait r\u00e9soudre le probl\u00e8me pour n-1 diques . Repr\u00e9senter les \u00e9tapes permettant de d\u00e9placer le n \u00e8me disque et la pile de n-1 disques (qui se d\u00e9place en entier, on suppose qu'on sait le faire) , de mani\u00e8re \u00e0 r\u00e9soudre le probl\u00e8me : R\u00e9capituler les trois \u00e9tapes de r\u00e9solution du probl\u00e8me : Etape 1 : Etape 2 : Etape 3 :","title":"A. Du cas particulier au cas g\u00e9n\u00e9ral"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#b-algorithme","text":"Pour r\u00e9soudre le probl\u00e8me pour n disques, on fait appel, 2 fois, \u00e0 la r\u00e9solution du probl\u00e8me pour n-1 disques. Nous allons donc utiliser un algorithme r\u00e9cursif. On propose le pseudo-code suivant : fonction Hanoi(n, dep, inter, arr) ''' Affiche les d\u00e9placements pour r\u00e9soudre le probl\u00e8me de Hano\u00ef pour n disques Entr\u00e9es : n : entier repr\u00e9sentant le nombre de disques \u00e0 d\u00e9placer dep, inter, arr : caract\u00e8res indiquant les sommets de d\u00e9part, interm\u00e9diaire et d'arriv\u00e9e ''' Si n est \u00e9gal \u00e0 0 retourner Rien Sinon Hanoi(.........................) afficher le d\u00e9placement depuis dep jusqu\u2019\u00e0 arr Hanoi(.........................) Compl\u00e9ter le pseudo-code avec les bons param\u00e8tres pour les appels r\u00e9cursifs \u00e0 la fonction Hanoi .","title":"B. Algorithme"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#c-implementation","text":"Ecrire l'impl\u00e9mentation en Python de cet algorithme ci-dessous : N.B.: Pour l'affichage, on peut utiliser une instruction du type : print(\"D\u00e9placer le disque \", str(n), \"de la tige \", dep, \" vers la tige \", arr) Pour visualiser ce qu'il se passe, compl\u00e9ter le fichier Python fourni (sur l'ENT) .","title":"C. Impl\u00e9mentation"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#_1","text":"","title":""},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#tp-dessiner-des-fractales","text":"Une fractale est un objet qui appara\u00eet identique \u00e0 diff\u00e9rentes \u00e9chelles : en \"zoomant\" sur une partie de la figure, on retrouve la figure initiale. On peut repr\u00e9senter une version approch\u00e9e des fractales avec des programmes r\u00e9cursifs, dont on d\u00e9fini le niveau de r\u00e9cursion (donc le niveau de d\u00e9tails de la figure).","title":"TP : Dessiner des fractales"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#1-des-bulles","text":"Le code suivant (accessible sur l'ENT) permet de dessiner une figure avec des bulles. Il utilise la biblioth\u00e8que turtle dont des \u00e9l\u00e9ments de documentation sont donn\u00e9s dans le fichier. from turtle import * def dessine_cercle(x, y, r): up() goto(x,y-r) down() circle(r) return None def bubble(n, x, y, r): if n == 0: return None else: dessine_cercle(x,y,r) bubble(n-1, x+3/2*r, y, r/2) bubble(n-1, x, y-3/2*r, r/2) return None bubble(4,-100,100,50) done() Ex\u00e9cuter le code. Faire varier la valeur de n pour augmenter le niveau de d\u00e9tails de la figure. Identifier les appels r\u00e9cursifs de la fonction bubble . Quel param\u00e8tre permet de r\u00e9duire la taille des bulles au fur et \u00e0 mesure ? Quels param\u00e8tres changent la position de la tortue ? La variation de quel param\u00e8tre nous assure que l'algorithme va se terminer ?","title":"1. Des bulles"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#2-le-flocon-de-von-koch","text":"Le flocon de Von Koch est une des premi\u00e8res courbes fractales \u00e0 avoir \u00e9t\u00e9 d\u00e9crite. Elle a \u00e9t\u00e9 invent\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Helge von Koch. Voici une partie de ce flocon :","title":"2. Le flocon de von Koch"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#2a-principe","text":"On commence par un segment de longueur a . On coupe ce segment en 3 parties \u00e9gales. On remplace le segment central par un triangle \u00e9quilat\u00e9ral de c\u00f4t\u00e9 a/3 . Chaque segment de longueur a/3 est lui-m\u00eame d\u00e9coup\u00e9 en 3 parties \u00e9gales (chacune de longueur a/9 ). On remplace chaque partie centrale par un triangle \u00e9quilat\u00e9ral de c\u00f4t\u00e9 a/9 . etc.","title":"2.A. Principe"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#2b-algorithme","text":"Nous allons utiliser un algorithme similaire \u00e0 celui qui permet de tracer le motif avec les bulles pour dessiner ce flocon. Compl\u00e9ter l'algorithme propos\u00e9 : fonction fragment_flocon(n, cote): ENTREES : n : entier indiquant le nombre d\u2019it\u00e9ration \u00e0 faire cote : la longueur du segment initial Si n est \u00e9gal \u00e0 0 alors On trace le segment de longueur cote Sinon On appelle la fonction fragment_flocon avec les param\u00e8tres __________ On tourne de _____ degr\u00e9s sur la _______________ ___________________________________________________ __________________________________________ ___________________________________________________ __________________________________________ ___________________________________________________","title":"2.B. Algorithme"},{"location":"tle/seq2/r%C3%A9cursivit%C3%A9/#2c-implementation","text":"Impl\u00e9menter l'algorithme en Python permettant de dessiner une partie du flocon. Ecrire la fonction flocon dessinant le flocon en entier.","title":"2.C. Impl\u00e9mentation"},{"location":"tle/seq3/Cours_SoC/","text":"body { text-align: justify} S\u00e9quence 3 Cours : Les syst\u00e8mes sur puce Pour simplifier les co\u00fbts, les concepteurs de circuits \u00e9lectroniques recherchent en permanence l\u2019int\u00e9gration maximale. L\u2019objectif est d\u2019implanter toutes les fonctions d\u2019un syst`eme sur une seule puce. La difficult\u00e9 vient de la diversit\u00e9 des technologies qui doivent cohabiter sur la m\u00eame puce, sans interf\u00e9rer les unes avec les autres. Ces syst\u00e8mes se rencontrent dans l\u2019informatique embarqu\u00e9e : dans les syst\u00e8mes de traitement de l\u2019information agissant de mani\u00e8re autonome. On parle de syst\u00e8mes sur puce ou SoC de l\u2019anglais \"System on a Chip\" . A. Pr\u00e9sentation A partir de la vid\u00e9o \"C'est pas sorcier : Nanomonde se secoue les puces\" , r\u00e9pondre aux questions suivantes : Quel est l'ordre de grandeur du nombre de composants que l'on trouve dans une puce ? Combien de transistors faut-il pour inverser un courant (de 1 \u00e0 0 et de 0 \u00e0 1) ? Pour additionner des chiffres ? Que dit la loi de Moore ? Quelle est l'ordre de grandeur de la taille d'un transistor en 2003 (date de la vid\u00e9o) ? B. Etude d\u2019un exemple Le sch\u00e9ma suivant d\u00e9crit le SoC BCM2711 qui \u00e9quipe les petits ordinateurs Raspberry Pi : Identifier les diff\u00e9rents composants de l'architecture de von Neumann. Faire des recherches pour trouver les caract\u00e9ristiques suivantes : nombre de coeurs : fr\u00e9quence : capacit\u00e9 de m\u00e9moire : connectique : r\u00e9seau : C. Avantages et inconv\u00e9nients A partir de ce que vous avez vu dans le cours, et d'une recherche Web : - Lister les avantages d\u2019un SoC. - Lister les inconv\u00e9nients d\u2019un SoC.","title":"II. Les syst\u00e8mes sur puce"},{"location":"tle/seq3/Cours_SoC/#sequence-3","text":"","title":"S\u00e9quence 3"},{"location":"tle/seq3/Cours_SoC/#cours-les-systemes-sur-puce","text":"Pour simplifier les co\u00fbts, les concepteurs de circuits \u00e9lectroniques recherchent en permanence l\u2019int\u00e9gration maximale. L\u2019objectif est d\u2019implanter toutes les fonctions d\u2019un syst`eme sur une seule puce. La difficult\u00e9 vient de la diversit\u00e9 des technologies qui doivent cohabiter sur la m\u00eame puce, sans interf\u00e9rer les unes avec les autres. Ces syst\u00e8mes se rencontrent dans l\u2019informatique embarqu\u00e9e : dans les syst\u00e8mes de traitement de l\u2019information agissant de mani\u00e8re autonome. On parle de syst\u00e8mes sur puce ou SoC de l\u2019anglais \"System on a Chip\" .","title":"Cours : Les syst\u00e8mes sur puce"},{"location":"tle/seq3/Cours_SoC/#a-presentation","text":"A partir de la vid\u00e9o \"C'est pas sorcier : Nanomonde se secoue les puces\" , r\u00e9pondre aux questions suivantes : Quel est l'ordre de grandeur du nombre de composants que l'on trouve dans une puce ? Combien de transistors faut-il pour inverser un courant (de 1 \u00e0 0 et de 0 \u00e0 1) ? Pour additionner des chiffres ? Que dit la loi de Moore ? Quelle est l'ordre de grandeur de la taille d'un transistor en 2003 (date de la vid\u00e9o) ?","title":"A. Pr\u00e9sentation"},{"location":"tle/seq3/Cours_SoC/#b-etude-dun-exemple","text":"Le sch\u00e9ma suivant d\u00e9crit le SoC BCM2711 qui \u00e9quipe les petits ordinateurs Raspberry Pi : Identifier les diff\u00e9rents composants de l'architecture de von Neumann. Faire des recherches pour trouver les caract\u00e9ristiques suivantes : nombre de coeurs : fr\u00e9quence : capacit\u00e9 de m\u00e9moire : connectique : r\u00e9seau :","title":"B. Etude d\u2019un exemple"},{"location":"tle/seq3/Cours_SoC/#c-avantages-et-inconvenients","text":"A partir de ce que vous avez vu dans le cours, et d'une recherche Web : - Lister les avantages d\u2019un SoC. - Lister les inconv\u00e9nients d\u2019un SoC.","title":"C. Avantages et inconv\u00e9nients"},{"location":"tle/seq4/dico/","text":"body { text-align: justify} S\u00e9quence 4 III. Les dictionnaires Cours A. D\u00e9finition Les dictionnaires ou tableaux associatifs sont des structures de donn\u00e9es non-lin\u00e9aires, o\u00f9 des valeurs sont associ\u00e9es \u00e0 des cl\u00e9s . B. Type abstrait Les op\u00e9rations primitives pouvant \u00eatre faites sur les dictionnaires sont les suivantes : - ajout d'une nouvelle valeur \u00e0 une nouvelle cl\u00e9, - modification de la valeur associ\u00e9e \u00e0 une cl\u00e9 existante, - suppression d'une cl\u00e9 et de la valeur associ\u00e9e, - recherche de la valeur associ\u00e9e \u00e0 une cl\u00e9. Ils sont impl\u00e9ment\u00e9s directement en Python avec le type dict . Rappels : Comment vous pouvez effectuer les op\u00e9rations primitives sur un dictionnaire Python, not\u00e9 d ? Commencer par cr\u00e9er un dictionnaire vide. d = {} d[cle] = v1 #ajout d'une nouvelle valeur \u00e0 une nouvelle cl\u00e9 d[cle] = v2 #modification de la valeur associ\u00e9e \u00e0 cle d.pop(cle) #supprime cle et sa valeur associ\u00e9e print(d['cle']) #recherche de la valeur associ\u00e9e \u00e0 cle Avec quelle m\u00e9thode acc\u00e8de-t-on \u00e0 la liste des cl\u00e9s de d ? A la liste de ses valeurs ? d.keys() et d.values() donnent respectivement la liste des cl\u00e9s et des valeurs. Comment peut-on afficher l'ensemble des cl\u00e9s et des valeurs associ\u00e9es, en parcourant d ? for cle in d: print(cle, d[cle]) d.items() #donne la liste des couples C. Acc\u00e8s \u00e0 un \u00e9l\u00e9ment L' acc\u00e8s \u00e0 un \u00e9l\u00e9ment dans un tableau associatif s'effectue, comme dans un tableau, en temps constant . Il est ind\u00e9pendant de la taille de la structure. L'impl\u00e9mentation d'un dictionnaire est en effet faite gr\u00e2ce \u00e0 une table de hachage (hors programme) qui associe \u00e0 chaque couple cl\u00e9-valeur un indice du tableau. Exercice : 1) \u00c9crire en Python une fonction tabToDict qui prend en param\u00e8tre d\u2019entr\u00e9e une liste Python de la forme [cl\u00e91, valeur1, cl\u00e92, valeur2,\u2026] et retourne un dictionnaire correspondant de la forme { cl\u00e91 : valeur1, cl\u00e92 : valeur2,\u2026}. Correction : def tabToDict(t): d = {} for i in range(0, len(t), 2): d[t[i]] = t[i+1] return d 2) R\u00e9ciproquement, \u00e9crire une fonction en Python dictToTab qui permet de passer d'un dictionnaire \u00e0 une liste. Correction : def dictToTab(d): l = [] for c in d.keys(): l.append(c) l.append(d[c]) return l","title":"III. Les dictionnaires"},{"location":"tle/seq4/dico/#sequence-4","text":"","title":"S\u00e9quence 4"},{"location":"tle/seq4/dico/#iii-les-dictionnaires","text":"","title":"III. Les dictionnaires"},{"location":"tle/seq4/dico/#cours","text":"","title":"Cours"},{"location":"tle/seq4/dico/#a-definition","text":"Les dictionnaires ou tableaux associatifs sont des structures de donn\u00e9es non-lin\u00e9aires, o\u00f9 des valeurs sont associ\u00e9es \u00e0 des cl\u00e9s .","title":"A. D\u00e9finition"},{"location":"tle/seq4/dico/#b-type-abstrait","text":"Les op\u00e9rations primitives pouvant \u00eatre faites sur les dictionnaires sont les suivantes : - ajout d'une nouvelle valeur \u00e0 une nouvelle cl\u00e9, - modification de la valeur associ\u00e9e \u00e0 une cl\u00e9 existante, - suppression d'une cl\u00e9 et de la valeur associ\u00e9e, - recherche de la valeur associ\u00e9e \u00e0 une cl\u00e9. Ils sont impl\u00e9ment\u00e9s directement en Python avec le type dict . Rappels : Comment vous pouvez effectuer les op\u00e9rations primitives sur un dictionnaire Python, not\u00e9 d ? Commencer par cr\u00e9er un dictionnaire vide. d = {} d[cle] = v1 #ajout d'une nouvelle valeur \u00e0 une nouvelle cl\u00e9 d[cle] = v2 #modification de la valeur associ\u00e9e \u00e0 cle d.pop(cle) #supprime cle et sa valeur associ\u00e9e print(d['cle']) #recherche de la valeur associ\u00e9e \u00e0 cle Avec quelle m\u00e9thode acc\u00e8de-t-on \u00e0 la liste des cl\u00e9s de d ? A la liste de ses valeurs ? d.keys() et d.values() donnent respectivement la liste des cl\u00e9s et des valeurs. Comment peut-on afficher l'ensemble des cl\u00e9s et des valeurs associ\u00e9es, en parcourant d ? for cle in d: print(cle, d[cle]) d.items() #donne la liste des couples","title":"B. Type abstrait"},{"location":"tle/seq4/dico/#c-acces-a-un-element","text":"L' acc\u00e8s \u00e0 un \u00e9l\u00e9ment dans un tableau associatif s'effectue, comme dans un tableau, en temps constant . Il est ind\u00e9pendant de la taille de la structure. L'impl\u00e9mentation d'un dictionnaire est en effet faite gr\u00e2ce \u00e0 une table de hachage (hors programme) qui associe \u00e0 chaque couple cl\u00e9-valeur un indice du tableau. Exercice : 1) \u00c9crire en Python une fonction tabToDict qui prend en param\u00e8tre d\u2019entr\u00e9e une liste Python de la forme [cl\u00e91, valeur1, cl\u00e92, valeur2,\u2026] et retourne un dictionnaire correspondant de la forme { cl\u00e91 : valeur1, cl\u00e92 : valeur2,\u2026}. Correction : def tabToDict(t): d = {} for i in range(0, len(t), 2): d[t[i]] = t[i+1] return d 2) R\u00e9ciproquement, \u00e9crire une fonction en Python dictToTab qui permet de passer d'un dictionnaire \u00e0 une liste. Correction : def dictToTab(d): l = [] for c in d.keys(): l.append(c) l.append(d[c]) return l","title":"C. Acc\u00e8s \u00e0 un \u00e9l\u00e9ment"},{"location":"tle/seq4/files/","text":"body { text-align: justify} S\u00e9quence 4 II. Les files Cours A. D\u00e9finition Une file est une structure de donn\u00e9es bas\u00e9e sur le principe \u00ab premier entr\u00e9, premier sorti \u00bb (en anglais \"First In, First Out\" (FIFO)), c\u2019est-\u00e0-dire que les premiers \u00e9l\u00e9ments ajout\u00e9s \u00e0 la file seront les premiers \u00e0 \u00eatre enlev\u00e9s. Exemples de la vie quotidienne : - pour repr\u00e9senter le syst\u00e8me de queue dans un magasin, - pour repr\u00e9senter le flux de v\u00e9hicules sur une route, - pour stocker des dossiers en attente dans une entreprise,... Exemples en informatique : - pour la gestion du temps affect\u00e9 \u00e0 chaque t\u00e2che par un syst\u00e8me d'exploitation, - pour la gestion de la file d'attente de documents \u00e0 imprimer, - pour mat\u00e9rialiser une file d'attente d'un logiciel de visioconf\u00e9rence, d'un jeu en ligne,... B. Type abstrait Les op\u00e9rations primitives que l'on peut faire sur une file sont les suivantes : - construire une file vide ( fileCree() ), - ajouter un \u00e9l\u00e9ment \u00e0 la file (il se retrouve apr\u00e8s les autres) ( fileAjouterFin(file, element) ), - enlever un \u00e9l\u00e9ment de la file (le premier ajout\u00e9 : celui en t\u00eate) et le renvoie ( fileRetirerTete(file) ), - estimer si la file est vide ( True ) ou non ( False ) ( fileEstVide(file) ), - obtenir le nombre d'\u00e9l\u00e9ments contenus dans la file ( fileTaille(file) ), - obtenir la t\u00eate de la file, aussi appel\u00e9 sommet (sans la retirer) ( fileTete(file) ). Exercice : En utilisant les noms des fonctions donn\u00e9s ci-dessus, cr\u00e9er une file, lui ajouter les \u00e9l\u00e9ments 2 et 9, puis lui enlever le dernier \u00e9l\u00e9ment r\u00e9cup\u00e9r\u00e9 dans une variable, avant d'estimer si elle est vide. Correction : f = fileCree() f = enfiler(f, 2) f = enfiler(f, 9) x = enfiler(f) print(fileVide(f)) C. Les structures lin\u00e9aires de donn\u00e9es Les listes , piles et files sont des structures lin\u00e9aires de donn\u00e9es : c'est-\u00e0-dire que les diff\u00e9rents \u00e9l\u00e9ments sont ordonn\u00e9s et adjacents les uns aux autres. Les piles et les files contrastent par leur ordre d'acc\u00e8s aux donn\u00e9es est oppos\u00e9 : LIFO vs FIFO. TP : Impl\u00e9mentations Dans ce TD, nous allons impl\u00e9menter la structure de file , de plusieurs mani\u00e8res diff\u00e9rentes. A. Une premi\u00e8re impl\u00e9mentation Une premi\u00e8re impl\u00e9mentation est donn\u00e9e ci-dessous. A partir de ce code, cr\u00e9er une file et enfiler successivement les entiers de 0 \u00e0 4. def file(): ''' Renvoie une file vide ''' return [] def vide(f): ''' Renvoie True si la file est vide, False sinon ''' return f == [] def enfiler(f,x): ''' Ajoute x \u00e0 la file f ''' return f.append(x) def defiler(f): ''' Enl\u00e8ve et renvoie le premier \u00e9l\u00e9ment de la file ''' assert not vide(f), \"file vide !\" return f.pop(0) Cr\u00e9er les fonctions suivantes : - taille : renvoie la taille d'une file f , - sommet : renvoie le sommet d'une file f , sans l'enlever de la file. Les tester sur la file f cr\u00e9\u00e9e pr\u00e9c\u00e9demment. B. Impl\u00e9mentation avec deux piles Pour la deuxi\u00e8me implantation, nous allons utiliser deux structures de piles et la programmation orient\u00e9e objet. Le proc\u00e9d\u00e9 est le suivant : - La file est, au d\u00e9part, compos\u00e9e de deux piles vides : une pile d'entr\u00e9e et une pile de sortie . - Quand on ajoute un \u00e9l\u00e9ment dans la file, on le place dans la pile d'entr\u00e9e . - Quand on supprime un \u00e9l\u00e9ment de la file, deux cas se pr\u00e9sentent : 1. Si la pile de sortie est vide : on d\u00e9pile alors chaque \u00e9l\u00e9ment de la pile d'entr\u00e9e pour les empiler dans la pile de sortie. 2. S'il y a au moins un \u00e9l\u00e9ment dans la pile de sortie : on ne fait rien. 3. On supprime ensuite le sommet de la pile de sortie. On utilise donc une classe Pile , et on propose la code de la classe File ci-dessous. - Compl\u00e9ter les m\u00e9thodes propos\u00e9es pour impl\u00e9menter la structure de file. - Ajouter \u00e0 la classe File les m\u00e9thodes suivantes : 1. sommet : retourne le sommet de la file, sans l'en enlever. 2. taille : retourne le nombre d'\u00e9l\u00e9ments de la file. class Pile: ''' D\u00e9finition d'une classe Pile une instance Pile est cr\u00e9\u00e9e avec une liste Python ''' def __init__(self): \"Cr\u00e9ation d'une pile vide\" self.L = [] def vide(self): \"Teste si la pile est vide\" return self.L == [] def depiler(self): \"D\u00e9pile : enl\u00e8ve le dernier \u00e9l\u00e9ment\" assert( not(self.vide()) ), \"Pile vide !\" return self.L.pop() def empiler(self,x): \"Empile : ajoute un \u00e9l\u00e9ment x en haut de la pile\" self.L.append(x) def taille(self): \"Retourne la taille (le nombre d'\u00e9l\u00e9ments) de la pile\" return len(self.L) def sommet(self): \"Retourne le premier \u00e9l\u00e9ment \u00e0 sortir de la pile sans le d\u00e9piler\" return self.L[self.taille()-1] class File: def __init__(self): ''' Cr\u00e9e une file vide. Attribut pile_entree : objet Pile stockant les nouvelles valeurs ajout\u00e9es \u00e0 la file. Attribut pile_sortie : objet Pile stockant les valeurs qui vont sortir de la file. Son sommet est le premier \u00e9l\u00e9ment de la file. ''' self.pile_entree = Pile() self.pile_sortie = Pile() def vide(self): ''' Teste si la file est vide ou non. ''' return ??? def enfiler(self, x): ''' Ajoute l'\u00e9l\u00e9ment x \u00e0 la file.''' self.pile_entree.empiler(x) def organiser(self): ''' Fonction auxiliaire actualisant l'\u00e9tat de la pile de sortie lorsque l'on veut supprimer un \u00e9l\u00e9ment de la file. Si la pile de sortie est vide, on lui ajoute successivement les \u00e9l\u00e9ments que l'on d\u00e9pile \u00e0 la pile d'entr\u00e9e. ''' if self.pile_sortie.vide(): ??? def defiler(self): ''' Supprime le premier \u00e9l\u00e9ment entr\u00e9 dans la file. ''' self.organiser() ??? Tester le bon fonctionnement du code suivant : f = File() for i in range(5): f.enfiler(2*i) print(f.taille()) a = f.defiler() print(a) print(f.taille()) print(f.sommet()) C. Impl\u00e9mentation avec une liste Python En vous inspirant de l'impl\u00e9mentation d'une pile en POO que nous avions faite, proposer une impl\u00e9mentation similaire pour une structure de file : en utilisant une liste Python. On devra retrouver les m\u00eames primitives que pour les autres impl\u00e9mentations. Faire un test en cr\u00e9ant un nouvel objet File, et en lui appliquant les diff\u00e9rentes m\u00e9thodes. class File: # \u00e0 compl\u00e9ter D. L'impl\u00e9mentation Python Python poss\u00e8de sa propre impl\u00e9mentation de file, utilisable aussi pour mod\u00e9liser une pile. Il s'agit de la structure deque (\"double-ended queue\"). Utiliser sa documentation : https://docs.python.org/fr/3/library/collections.html#collections.deque pour choisir les m\u00e9thodes qui permettent de simuler le fonctionnement d'une file. On y retrouve des m\u00e9thodes similaires \u00e0 celles d\u00e9finies pour les listes Python, mais avec la possibilit\u00e9 d'ajouter et de supprimer des \u00e9l\u00e9ments soit \u00e0 droite, soit \u00e0 gauche. Rajouter, \u00e0 la suite du code ci-dessous, des instructions qui permettent de cr\u00e9er un objet deque , de lui enfiler plusieurs \u00e9l\u00e9ments, d'estimer si la file est vide, et de d\u00e9filer un \u00e9l\u00e9ment. Il y a plusieurs solutions. from collections import deque TD : Mod\u00e9lisation A. Pr\u00e9sentation On souhaite \u00e9crire un algorithme qui simule l'arriv\u00e9e de voitures sur la route R3, mod\u00e9lis\u00e9e par la file f3 . - Dans la file f1 , on repr\u00e9sente la pr\u00e9sence d\u2019une voiture par le nombre 1 et l\u2019absence de voiture par 0 . - Dans la file f2 , on repr\u00e9sentera la pr\u00e9sence d\u2019une voiture par le nombre 2 et l\u2019absence de voiture par 0 . Donner la file f1 correspondant \u00e0 la situation suivante : une voiture, pas de voiture, pas de voiture, une voiture, une voiture, pas de voiture. Donner la file f2 correspondant \u00e0 la situation suivante : pas de voiture, pas de voiture, une voiture, une voiture, pas de voiture, une voiture. B. Les diff\u00e9rents cas Que doit faire l\u2019algorithme si : - les deux sommets des files sont \u00e0 0 ? - le sommet de f1 est \u00e0 1 et celui de f2 \u00e0 2 ? - le sommet de f1 est \u00e0 1 et celui de f2 \u00e0 0 ? - le sommet de f1 est \u00e0 0 et celui de f2 \u00e0 2 ? - l\u2019une des deux files est vide ? Donner la file f3 correspondant aux files entrantes suivantes : f1 : t\u00eate <\u2013 [0, 1, 1, 0, 1] <\u2013 queue f2 : t\u00eate <\u2013 [0, 2, 2, 2, 0, 2, 0] <\u2013 queue C. Construction de l\u2019algorithme Ecrire sous la forme d\u2019un pseudo-code la fonction croisement prenant en entr\u00e9es les deux files f1 et f2 , et retournant la file f3 . Tous les cas identifi\u00e9s dans la partie pr\u00e9c\u00e9dente devront \u00eatre trait\u00e9s. On n\u2019utilisera que les primitives utilisables sur les files. D. Impl\u00e9mentation de l\u2019algorithme Impl\u00e9menter le pseudo-code pr\u00e9c\u00e9dent et le tester sur l\u2019exemple donn\u00e9 dans la partie 2. On utilisera une impl\u00e9mentation de file avec la POO, utilisant les m\u00e9thodes enfiler , defiler , sommet et estVide .","title":"II. Les files"},{"location":"tle/seq4/files/#sequence-4","text":"","title":"S\u00e9quence 4"},{"location":"tle/seq4/files/#ii-les-files","text":"","title":"II. Les files"},{"location":"tle/seq4/files/#cours","text":"","title":"Cours"},{"location":"tle/seq4/files/#a-definition","text":"Une file est une structure de donn\u00e9es bas\u00e9e sur le principe \u00ab premier entr\u00e9, premier sorti \u00bb (en anglais \"First In, First Out\" (FIFO)), c\u2019est-\u00e0-dire que les premiers \u00e9l\u00e9ments ajout\u00e9s \u00e0 la file seront les premiers \u00e0 \u00eatre enlev\u00e9s. Exemples de la vie quotidienne : - pour repr\u00e9senter le syst\u00e8me de queue dans un magasin, - pour repr\u00e9senter le flux de v\u00e9hicules sur une route, - pour stocker des dossiers en attente dans une entreprise,... Exemples en informatique : - pour la gestion du temps affect\u00e9 \u00e0 chaque t\u00e2che par un syst\u00e8me d'exploitation, - pour la gestion de la file d'attente de documents \u00e0 imprimer, - pour mat\u00e9rialiser une file d'attente d'un logiciel de visioconf\u00e9rence, d'un jeu en ligne,...","title":"A. D\u00e9finition"},{"location":"tle/seq4/files/#b-type-abstrait","text":"Les op\u00e9rations primitives que l'on peut faire sur une file sont les suivantes : - construire une file vide ( fileCree() ), - ajouter un \u00e9l\u00e9ment \u00e0 la file (il se retrouve apr\u00e8s les autres) ( fileAjouterFin(file, element) ), - enlever un \u00e9l\u00e9ment de la file (le premier ajout\u00e9 : celui en t\u00eate) et le renvoie ( fileRetirerTete(file) ), - estimer si la file est vide ( True ) ou non ( False ) ( fileEstVide(file) ), - obtenir le nombre d'\u00e9l\u00e9ments contenus dans la file ( fileTaille(file) ), - obtenir la t\u00eate de la file, aussi appel\u00e9 sommet (sans la retirer) ( fileTete(file) ). Exercice : En utilisant les noms des fonctions donn\u00e9s ci-dessus, cr\u00e9er une file, lui ajouter les \u00e9l\u00e9ments 2 et 9, puis lui enlever le dernier \u00e9l\u00e9ment r\u00e9cup\u00e9r\u00e9 dans une variable, avant d'estimer si elle est vide. Correction : f = fileCree() f = enfiler(f, 2) f = enfiler(f, 9) x = enfiler(f) print(fileVide(f))","title":"B. Type abstrait"},{"location":"tle/seq4/files/#c-les-structures-lineaires-de-donnees","text":"Les listes , piles et files sont des structures lin\u00e9aires de donn\u00e9es : c'est-\u00e0-dire que les diff\u00e9rents \u00e9l\u00e9ments sont ordonn\u00e9s et adjacents les uns aux autres. Les piles et les files contrastent par leur ordre d'acc\u00e8s aux donn\u00e9es est oppos\u00e9 : LIFO vs FIFO.","title":"C. Les structures lin\u00e9aires de donn\u00e9es"},{"location":"tle/seq4/files/#tp-implementations","text":"Dans ce TD, nous allons impl\u00e9menter la structure de file , de plusieurs mani\u00e8res diff\u00e9rentes.","title":"TP : Impl\u00e9mentations"},{"location":"tle/seq4/files/#a-une-premiere-implementation","text":"Une premi\u00e8re impl\u00e9mentation est donn\u00e9e ci-dessous. A partir de ce code, cr\u00e9er une file et enfiler successivement les entiers de 0 \u00e0 4. def file(): ''' Renvoie une file vide ''' return [] def vide(f): ''' Renvoie True si la file est vide, False sinon ''' return f == [] def enfiler(f,x): ''' Ajoute x \u00e0 la file f ''' return f.append(x) def defiler(f): ''' Enl\u00e8ve et renvoie le premier \u00e9l\u00e9ment de la file ''' assert not vide(f), \"file vide !\" return f.pop(0) Cr\u00e9er les fonctions suivantes : - taille : renvoie la taille d'une file f , - sommet : renvoie le sommet d'une file f , sans l'enlever de la file. Les tester sur la file f cr\u00e9\u00e9e pr\u00e9c\u00e9demment.","title":"A. Une premi\u00e8re impl\u00e9mentation"},{"location":"tle/seq4/files/#b-implementation-avec-deux-piles","text":"Pour la deuxi\u00e8me implantation, nous allons utiliser deux structures de piles et la programmation orient\u00e9e objet. Le proc\u00e9d\u00e9 est le suivant : - La file est, au d\u00e9part, compos\u00e9e de deux piles vides : une pile d'entr\u00e9e et une pile de sortie . - Quand on ajoute un \u00e9l\u00e9ment dans la file, on le place dans la pile d'entr\u00e9e . - Quand on supprime un \u00e9l\u00e9ment de la file, deux cas se pr\u00e9sentent : 1. Si la pile de sortie est vide : on d\u00e9pile alors chaque \u00e9l\u00e9ment de la pile d'entr\u00e9e pour les empiler dans la pile de sortie. 2. S'il y a au moins un \u00e9l\u00e9ment dans la pile de sortie : on ne fait rien. 3. On supprime ensuite le sommet de la pile de sortie. On utilise donc une classe Pile , et on propose la code de la classe File ci-dessous. - Compl\u00e9ter les m\u00e9thodes propos\u00e9es pour impl\u00e9menter la structure de file. - Ajouter \u00e0 la classe File les m\u00e9thodes suivantes : 1. sommet : retourne le sommet de la file, sans l'en enlever. 2. taille : retourne le nombre d'\u00e9l\u00e9ments de la file. class Pile: ''' D\u00e9finition d'une classe Pile une instance Pile est cr\u00e9\u00e9e avec une liste Python ''' def __init__(self): \"Cr\u00e9ation d'une pile vide\" self.L = [] def vide(self): \"Teste si la pile est vide\" return self.L == [] def depiler(self): \"D\u00e9pile : enl\u00e8ve le dernier \u00e9l\u00e9ment\" assert( not(self.vide()) ), \"Pile vide !\" return self.L.pop() def empiler(self,x): \"Empile : ajoute un \u00e9l\u00e9ment x en haut de la pile\" self.L.append(x) def taille(self): \"Retourne la taille (le nombre d'\u00e9l\u00e9ments) de la pile\" return len(self.L) def sommet(self): \"Retourne le premier \u00e9l\u00e9ment \u00e0 sortir de la pile sans le d\u00e9piler\" return self.L[self.taille()-1] class File: def __init__(self): ''' Cr\u00e9e une file vide. Attribut pile_entree : objet Pile stockant les nouvelles valeurs ajout\u00e9es \u00e0 la file. Attribut pile_sortie : objet Pile stockant les valeurs qui vont sortir de la file. Son sommet est le premier \u00e9l\u00e9ment de la file. ''' self.pile_entree = Pile() self.pile_sortie = Pile() def vide(self): ''' Teste si la file est vide ou non. ''' return ??? def enfiler(self, x): ''' Ajoute l'\u00e9l\u00e9ment x \u00e0 la file.''' self.pile_entree.empiler(x) def organiser(self): ''' Fonction auxiliaire actualisant l'\u00e9tat de la pile de sortie lorsque l'on veut supprimer un \u00e9l\u00e9ment de la file. Si la pile de sortie est vide, on lui ajoute successivement les \u00e9l\u00e9ments que l'on d\u00e9pile \u00e0 la pile d'entr\u00e9e. ''' if self.pile_sortie.vide(): ??? def defiler(self): ''' Supprime le premier \u00e9l\u00e9ment entr\u00e9 dans la file. ''' self.organiser() ??? Tester le bon fonctionnement du code suivant : f = File() for i in range(5): f.enfiler(2*i) print(f.taille()) a = f.defiler() print(a) print(f.taille()) print(f.sommet())","title":"B. Impl\u00e9mentation avec deux piles"},{"location":"tle/seq4/files/#c-implementation-avec-une-liste-python","text":"En vous inspirant de l'impl\u00e9mentation d'une pile en POO que nous avions faite, proposer une impl\u00e9mentation similaire pour une structure de file : en utilisant une liste Python. On devra retrouver les m\u00eames primitives que pour les autres impl\u00e9mentations. Faire un test en cr\u00e9ant un nouvel objet File, et en lui appliquant les diff\u00e9rentes m\u00e9thodes. class File: # \u00e0 compl\u00e9ter","title":"C. Impl\u00e9mentation avec une liste Python"},{"location":"tle/seq4/files/#d-limplementation-python","text":"Python poss\u00e8de sa propre impl\u00e9mentation de file, utilisable aussi pour mod\u00e9liser une pile. Il s'agit de la structure deque (\"double-ended queue\"). Utiliser sa documentation : https://docs.python.org/fr/3/library/collections.html#collections.deque pour choisir les m\u00e9thodes qui permettent de simuler le fonctionnement d'une file. On y retrouve des m\u00e9thodes similaires \u00e0 celles d\u00e9finies pour les listes Python, mais avec la possibilit\u00e9 d'ajouter et de supprimer des \u00e9l\u00e9ments soit \u00e0 droite, soit \u00e0 gauche. Rajouter, \u00e0 la suite du code ci-dessous, des instructions qui permettent de cr\u00e9er un objet deque , de lui enfiler plusieurs \u00e9l\u00e9ments, d'estimer si la file est vide, et de d\u00e9filer un \u00e9l\u00e9ment. Il y a plusieurs solutions. from collections import deque","title":"D. L'impl\u00e9mentation Python"},{"location":"tle/seq4/files/#td-modelisation","text":"","title":"TD : Mod\u00e9lisation"},{"location":"tle/seq4/files/#a-presentation","text":"On souhaite \u00e9crire un algorithme qui simule l'arriv\u00e9e de voitures sur la route R3, mod\u00e9lis\u00e9e par la file f3 . - Dans la file f1 , on repr\u00e9sente la pr\u00e9sence d\u2019une voiture par le nombre 1 et l\u2019absence de voiture par 0 . - Dans la file f2 , on repr\u00e9sentera la pr\u00e9sence d\u2019une voiture par le nombre 2 et l\u2019absence de voiture par 0 . Donner la file f1 correspondant \u00e0 la situation suivante : une voiture, pas de voiture, pas de voiture, une voiture, une voiture, pas de voiture. Donner la file f2 correspondant \u00e0 la situation suivante : pas de voiture, pas de voiture, une voiture, une voiture, pas de voiture, une voiture.","title":"A. Pr\u00e9sentation"},{"location":"tle/seq4/files/#b-les-differents-cas","text":"Que doit faire l\u2019algorithme si : - les deux sommets des files sont \u00e0 0 ? - le sommet de f1 est \u00e0 1 et celui de f2 \u00e0 2 ? - le sommet de f1 est \u00e0 1 et celui de f2 \u00e0 0 ? - le sommet de f1 est \u00e0 0 et celui de f2 \u00e0 2 ? - l\u2019une des deux files est vide ? Donner la file f3 correspondant aux files entrantes suivantes : f1 : t\u00eate <\u2013 [0, 1, 1, 0, 1] <\u2013 queue f2 : t\u00eate <\u2013 [0, 2, 2, 2, 0, 2, 0] <\u2013 queue","title":"B.  Les diff\u00e9rents cas"},{"location":"tle/seq4/files/#c-construction-de-lalgorithme","text":"Ecrire sous la forme d\u2019un pseudo-code la fonction croisement prenant en entr\u00e9es les deux files f1 et f2 , et retournant la file f3 . Tous les cas identifi\u00e9s dans la partie pr\u00e9c\u00e9dente devront \u00eatre trait\u00e9s. On n\u2019utilisera que les primitives utilisables sur les files.","title":"C. Construction de l\u2019algorithme"},{"location":"tle/seq4/files/#d-implementation-de-lalgorithme","text":"Impl\u00e9menter le pseudo-code pr\u00e9c\u00e9dent et le tester sur l\u2019exemple donn\u00e9 dans la partie 2. On utilisera une impl\u00e9mentation de file avec la POO, utilisant les m\u00e9thodes enfiler , defiler , sommet et estVide .","title":"D. Impl\u00e9mentation de l\u2019algorithme"},{"location":"tle/seq4/listes/","text":"body { text-align: justify} S\u00e9quence 4 I. Les listes Cours A. La notion de liste Une liste est un ensemble s\u00e9quentiel (les \u00e9l\u00e9ments sont les uns \u00e0 la suite des autres) de donn\u00e9es de m\u00eame type. Elle est classiquement impl\u00e9ment\u00e9e par : - un tableau , - une liste cha\u00een\u00e9e . D\u00e9finition : Un tableau est une suite indic\u00e9e d'\u00e9l\u00e9ments de m\u00eame type. L'avantage d'un tableau est que l'on peut acc\u00e9der directement \u00e0 chacun de ses \u00e9l\u00e9ments, gr\u00e2ce \u00e0 leur indice. Son inconv\u00e9nient est que sa taille est d\u00e9finie \u00e0 l'avance , et ne peut \u00eatre modifi\u00e9e. La liste cha\u00een\u00e9e se diff\u00e9rencie des tableaux par sa mani\u00e8re d'acc\u00e8der aux diff\u00e9rents \u00e9l\u00e9ments. B. La structure de liste cha\u00een\u00e9e D\u00e9finition : Une liste cha\u00een\u00e9e est une suite d'\u00e9l\u00e9ments compos\u00e9e : - d'une t\u00eate : le premier \u00e9l\u00e9ment auquel on peut acc\u00e9der, - d'une queue : le reste des \u00e9l\u00e9ments. Historiquement, le langage LISP (\"list processing\") est un des premiers \u00e0 introduire cette structure de donn\u00e9es en 1958. Dans ce langage, la t\u00eate est nomm\u00e9e car pour \"content of address register\" , et la queue cdr pour \"content of decrement register\" . Sur une liste, on peut effectuer les op\u00e9rations dites \"primitives\" suivantes : - cr\u00e9er une liste vide ( listeCree() ), - obtenir la t\u00eate de la liste ( listeTete(liste) ), - obtenir la queue de la liste ( listeQueue(liste) ), - renvoyer si la liste est vide ( True ) ou non ( False ) ( listeEstVide() ), - ajouter un \u00e9l\u00e9ment en t\u00eate d'une liste ( listeAjoute(element, liste) ). Exercice : en utilisant les fonctions d\u00e9finie ci-dessus, cr\u00e9er une liste cha\u00een\u00e9e initialement vide, \u00e0 laquelle on ajoute successivement les entiers 15, 2 et 3. L = listeCree() L = listeAjoute(15, L) L = listeAjoute(2, L) L = listeAjoute(3, L) # ou L = listeAjoute(3,listeAjoute(2,listeAjoute(15, listeCree()))) En quoi est-ce une structure r\u00e9cursive ? Une liste est une structure r\u00e9cursive car sa queue est elle-m\u00eame une liste. C. Stockage en m\u00e9moire Tableaux et listes cha\u00een\u00e9es se distinguent par leur utilisation de la m\u00e9moire. Un tableau est stock\u00e9 dans une suite contig\u00fce de cases m\u00e9moires. Sa taille est fixe : l'ajout d'un nouvel \u00e9l\u00e9ment, qui agrandirait la taille du tableau, n'est pas possible. En Python, la structure de liste correspond \u00e0 un tableau dynamique : un tableau auquel on peut ajouter des \u00e9l\u00e9ments. Ceux-ci devant toujours \u00eatre plac\u00e9s les uns \u00e0 c\u00f4t\u00e9 des autres, s'il n'y a pas de place pour ajouter ces donn\u00e9es dans les cases m\u00e9moires adjacentes... alors il faut r\u00e9\u00e9crire le tableau ailleurs. Les diff\u00e9rents \u00e9l\u00e9ments d'une liste cha\u00een\u00e9e ne sont pas stock\u00e9s de mani\u00e8re contig\u00fce : chaque \u00e9l\u00e9ment est associ\u00e9 \u00e0 2 cases m\u00e9moires : - une dans laquelle on stocke la valeur de l'\u00e9l\u00e9ment, - une dans laquelle on stocke l'adresse m\u00e9moire de l'\u00e9l\u00e9ment suivant . Il est donc tr\u00e8s facile d'ajouter des \u00e9l\u00e9ments \u00e0 une liste cha\u00een\u00e9e : Quelle op\u00e9ration faut-il faire ? Il faut lier le nouvel \u00e9l\u00e9ment \u00e0 l'\u00e9l\u00e9ment que l'on veut avoir avant, et faire pointer le nouvel \u00e9l\u00e9ment vers celui qui \u00e9tait \u00e0 sa position. Exercice : Ecrire une fonction elementListe prenant comme entr\u00e9es une liste L et un indice i et retournant l'\u00e9lement i de la liste. Quelle est la complexit\u00e9 de cette fonction ? def elementListe(L, i): if i == 1: return listeTete(L) else: return elementListe(listeQueue(L),i-1) Il faut parcourir tous les \u00e9l\u00e9ments pr\u00e9c\u00e9dents avant d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment i : la complexit\u00e9 est lin\u00e9aire (en O(n)). D. Interface et impl\u00e9mentation d'une structure de donn\u00e9es Nous avons vu en TD que l'on pouvait impl\u00e9menter de diff\u00e9rentes mani\u00e8res la m\u00eame structure de liste cha\u00een\u00e9e . Le type abstrait , ou d\u00e9finition de la structure ne change pas. On manipule la structure gr\u00e2ce \u00e0 son interface : la description des op\u00e9rations qui peuvent \u00eatre faites sur ces donn\u00e9es. La mani\u00e8re de les impl\u00e9menter peut varier, on aura utilis\u00e9 la m\u00eame structure. TP : Impl\u00e9mentations A. Premi\u00e8re impl\u00e9mentation On propose une premi\u00e8re impl\u00e9mentation d'une liste cha\u00een\u00e9e, qui est repr\u00e9sent\u00e9e par un tuple (tete, queue) : def listeCree(): return None def listeEstVide(l): return l == None def listeAjoute(x,l): return (x,l) def listeTete(l): return l[0] def listeQueue(l): return l[1] Ex\u00e9cuter les instructions suivantes : Cr\u00e9er une liste vide. V\u00e9rifier qu'elle est vide. Ajouter successivement les entiers de 0 \u00e0 4. V\u00e9rifier qu'elle n'est pas vide. Cr\u00e9er une fonction listeAffiche(l) qui affiche successivement les diff\u00e9rents \u00e9l\u00e9ments de la liste de mani\u00e8re r\u00e9cursive . Cr\u00e9er une fonction listeCompte(l) qui compte le nombre d'\u00e9l\u00e9ments dans une liste de mani\u00e8re r\u00e9cursive . Reprendre la liste de la question 1., et : Ajouter l'entier 5. Compter le nombre d'\u00e9l\u00e9ments et les afficher. Supprimer la t\u00eate de la liste. Compter \u00e0 nouveau le nombre d'\u00e9l\u00e9ments et les afficher. B. Deuxi\u00e8me impl\u00e9mentation (POO) On propose une deuxi\u00e8me impl\u00e9mentation qui utilise la POO. Elle se base sur deux classes : une classe Cellule qui repr\u00e9sente un \u00e9l\u00e9ment de la liste, et une classe Liste compos\u00e9e d'instances de la classe Cellule et impl\u00e9mentant les primitives d'une liste : class Cellule: def __init__(self, tete, queue): self.car = tete self.cdr = queue class Liste: def __init__(self, c): self.cellule = c def isnil(self): return self.cellule is None def car(self): assert(not(self.cellule is None)), 'Liste vide !' return self.cellule.car def cdr(self): assert(not(self.cellule is None)) return self.cellule.cdr def cons(self, e): return Liste(Cellule(e, self)) Remarque : On utilise ici les noms utilis\u00e9s par le langage Lisp pour impl\u00e9menter les primitives. Pour construire une liste, on utilise la m\u00e9thode cons qui ajoute un \u00e9l\u00e9ment en t\u00eate : nil = Liste(None) L = nil.cons(5).cons(4).cons(3).cons(2).cons(1) Repr\u00e9senter les \u00e9l\u00e9ments de la liste L en utilisant un sch\u00e9ma comme ceux du cours. Identifier le r\u00f4le des diff\u00e9rentes m\u00e9thodes et l'ajouter en commentaires. Tester le code suivant : print(L.isnil()) print(L.car()) print(L.cdr().car()) Ecrire l'instruction permettant d'afficher le dernier \u00e9l\u00e9ment de la liste. Cr\u00e9er les fonctions lengthList(l) et displayList(l) qui, respectivement, compte le nombre d'\u00e9l\u00e9ments dans la liste, et affiche chacun d'entre eux. On impl\u00e9mentera ces fonctions de mani\u00e8re r\u00e9cursive . Cr\u00e9er la fonction removeList(l) , qui supprime un \u00e9l\u00e9ment en t\u00eate de liste et le retourne. Pour aller plus loin... La liste cha\u00een\u00e9e vue en cours est une liste simplement cha\u00een\u00e9e : chaque \u00e9l\u00e9ment ne poss\u00e8de qu'un lien vers le suivant. Avec une liste doublement cha\u00een\u00e9e , chaque \u00e9l\u00e9ment poss\u00e8de un lien avec le suivant et avec le pr\u00e9c\u00e9dent. Cela permet les parcours de liste dans les deux sens. On propose les classes ci-dessous pour impl\u00e9menter cette structure. Ajouter les m\u00e9thodes insereDebut et insereFin \u00e0 la classe ListeDoublementChainee , permettant d'ins\u00e9rer des \u00e9l\u00e9ments au d\u00e9but ou \u00e0 la fin de la liste. class Maillon(): def __init__(self, e): self.element = e self.suivant = None self.precedent = None class ListeDoublementChainee(): def __init__(self, m): self.maillon_debut = m","title":"I. Les listes"},{"location":"tle/seq4/listes/#sequence-4","text":"","title":"S\u00e9quence 4"},{"location":"tle/seq4/listes/#i-les-listes","text":"","title":"I. Les listes"},{"location":"tle/seq4/listes/#cours","text":"","title":"Cours"},{"location":"tle/seq4/listes/#a-la-notion-de-liste","text":"Une liste est un ensemble s\u00e9quentiel (les \u00e9l\u00e9ments sont les uns \u00e0 la suite des autres) de donn\u00e9es de m\u00eame type. Elle est classiquement impl\u00e9ment\u00e9e par : - un tableau , - une liste cha\u00een\u00e9e . D\u00e9finition : Un tableau est une suite indic\u00e9e d'\u00e9l\u00e9ments de m\u00eame type. L'avantage d'un tableau est que l'on peut acc\u00e9der directement \u00e0 chacun de ses \u00e9l\u00e9ments, gr\u00e2ce \u00e0 leur indice. Son inconv\u00e9nient est que sa taille est d\u00e9finie \u00e0 l'avance , et ne peut \u00eatre modifi\u00e9e. La liste cha\u00een\u00e9e se diff\u00e9rencie des tableaux par sa mani\u00e8re d'acc\u00e8der aux diff\u00e9rents \u00e9l\u00e9ments.","title":"A. La notion de liste"},{"location":"tle/seq4/listes/#b-la-structure-de-liste-chainee","text":"D\u00e9finition : Une liste cha\u00een\u00e9e est une suite d'\u00e9l\u00e9ments compos\u00e9e : - d'une t\u00eate : le premier \u00e9l\u00e9ment auquel on peut acc\u00e9der, - d'une queue : le reste des \u00e9l\u00e9ments. Historiquement, le langage LISP (\"list processing\") est un des premiers \u00e0 introduire cette structure de donn\u00e9es en 1958. Dans ce langage, la t\u00eate est nomm\u00e9e car pour \"content of address register\" , et la queue cdr pour \"content of decrement register\" . Sur une liste, on peut effectuer les op\u00e9rations dites \"primitives\" suivantes : - cr\u00e9er une liste vide ( listeCree() ), - obtenir la t\u00eate de la liste ( listeTete(liste) ), - obtenir la queue de la liste ( listeQueue(liste) ), - renvoyer si la liste est vide ( True ) ou non ( False ) ( listeEstVide() ), - ajouter un \u00e9l\u00e9ment en t\u00eate d'une liste ( listeAjoute(element, liste) ). Exercice : en utilisant les fonctions d\u00e9finie ci-dessus, cr\u00e9er une liste cha\u00een\u00e9e initialement vide, \u00e0 laquelle on ajoute successivement les entiers 15, 2 et 3. L = listeCree() L = listeAjoute(15, L) L = listeAjoute(2, L) L = listeAjoute(3, L) # ou L = listeAjoute(3,listeAjoute(2,listeAjoute(15, listeCree()))) En quoi est-ce une structure r\u00e9cursive ? Une liste est une structure r\u00e9cursive car sa queue est elle-m\u00eame une liste.","title":"B. La structure de liste cha\u00een\u00e9e"},{"location":"tle/seq4/listes/#c-stockage-en-memoire","text":"Tableaux et listes cha\u00een\u00e9es se distinguent par leur utilisation de la m\u00e9moire. Un tableau est stock\u00e9 dans une suite contig\u00fce de cases m\u00e9moires. Sa taille est fixe : l'ajout d'un nouvel \u00e9l\u00e9ment, qui agrandirait la taille du tableau, n'est pas possible. En Python, la structure de liste correspond \u00e0 un tableau dynamique : un tableau auquel on peut ajouter des \u00e9l\u00e9ments. Ceux-ci devant toujours \u00eatre plac\u00e9s les uns \u00e0 c\u00f4t\u00e9 des autres, s'il n'y a pas de place pour ajouter ces donn\u00e9es dans les cases m\u00e9moires adjacentes... alors il faut r\u00e9\u00e9crire le tableau ailleurs. Les diff\u00e9rents \u00e9l\u00e9ments d'une liste cha\u00een\u00e9e ne sont pas stock\u00e9s de mani\u00e8re contig\u00fce : chaque \u00e9l\u00e9ment est associ\u00e9 \u00e0 2 cases m\u00e9moires : - une dans laquelle on stocke la valeur de l'\u00e9l\u00e9ment, - une dans laquelle on stocke l'adresse m\u00e9moire de l'\u00e9l\u00e9ment suivant . Il est donc tr\u00e8s facile d'ajouter des \u00e9l\u00e9ments \u00e0 une liste cha\u00een\u00e9e : Quelle op\u00e9ration faut-il faire ? Il faut lier le nouvel \u00e9l\u00e9ment \u00e0 l'\u00e9l\u00e9ment que l'on veut avoir avant, et faire pointer le nouvel \u00e9l\u00e9ment vers celui qui \u00e9tait \u00e0 sa position. Exercice : Ecrire une fonction elementListe prenant comme entr\u00e9es une liste L et un indice i et retournant l'\u00e9lement i de la liste. Quelle est la complexit\u00e9 de cette fonction ? def elementListe(L, i): if i == 1: return listeTete(L) else: return elementListe(listeQueue(L),i-1) Il faut parcourir tous les \u00e9l\u00e9ments pr\u00e9c\u00e9dents avant d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment i : la complexit\u00e9 est lin\u00e9aire (en O(n)).","title":"C. Stockage en m\u00e9moire"},{"location":"tle/seq4/listes/#d-interface-et-implementation-dune-structure-de-donnees","text":"Nous avons vu en TD que l'on pouvait impl\u00e9menter de diff\u00e9rentes mani\u00e8res la m\u00eame structure de liste cha\u00een\u00e9e . Le type abstrait , ou d\u00e9finition de la structure ne change pas. On manipule la structure gr\u00e2ce \u00e0 son interface : la description des op\u00e9rations qui peuvent \u00eatre faites sur ces donn\u00e9es. La mani\u00e8re de les impl\u00e9menter peut varier, on aura utilis\u00e9 la m\u00eame structure.","title":"D. Interface et impl\u00e9mentation d'une structure de donn\u00e9es"},{"location":"tle/seq4/listes/#tp-implementations","text":"","title":"TP : Impl\u00e9mentations"},{"location":"tle/seq4/listes/#a-premiere-implementation","text":"On propose une premi\u00e8re impl\u00e9mentation d'une liste cha\u00een\u00e9e, qui est repr\u00e9sent\u00e9e par un tuple (tete, queue) : def listeCree(): return None def listeEstVide(l): return l == None def listeAjoute(x,l): return (x,l) def listeTete(l): return l[0] def listeQueue(l): return l[1] Ex\u00e9cuter les instructions suivantes : Cr\u00e9er une liste vide. V\u00e9rifier qu'elle est vide. Ajouter successivement les entiers de 0 \u00e0 4. V\u00e9rifier qu'elle n'est pas vide. Cr\u00e9er une fonction listeAffiche(l) qui affiche successivement les diff\u00e9rents \u00e9l\u00e9ments de la liste de mani\u00e8re r\u00e9cursive . Cr\u00e9er une fonction listeCompte(l) qui compte le nombre d'\u00e9l\u00e9ments dans une liste de mani\u00e8re r\u00e9cursive . Reprendre la liste de la question 1., et : Ajouter l'entier 5. Compter le nombre d'\u00e9l\u00e9ments et les afficher. Supprimer la t\u00eate de la liste. Compter \u00e0 nouveau le nombre d'\u00e9l\u00e9ments et les afficher.","title":"A. Premi\u00e8re impl\u00e9mentation"},{"location":"tle/seq4/listes/#b-deuxieme-implementation-poo","text":"On propose une deuxi\u00e8me impl\u00e9mentation qui utilise la POO. Elle se base sur deux classes : une classe Cellule qui repr\u00e9sente un \u00e9l\u00e9ment de la liste, et une classe Liste compos\u00e9e d'instances de la classe Cellule et impl\u00e9mentant les primitives d'une liste : class Cellule: def __init__(self, tete, queue): self.car = tete self.cdr = queue class Liste: def __init__(self, c): self.cellule = c def isnil(self): return self.cellule is None def car(self): assert(not(self.cellule is None)), 'Liste vide !' return self.cellule.car def cdr(self): assert(not(self.cellule is None)) return self.cellule.cdr def cons(self, e): return Liste(Cellule(e, self)) Remarque : On utilise ici les noms utilis\u00e9s par le langage Lisp pour impl\u00e9menter les primitives. Pour construire une liste, on utilise la m\u00e9thode cons qui ajoute un \u00e9l\u00e9ment en t\u00eate : nil = Liste(None) L = nil.cons(5).cons(4).cons(3).cons(2).cons(1) Repr\u00e9senter les \u00e9l\u00e9ments de la liste L en utilisant un sch\u00e9ma comme ceux du cours. Identifier le r\u00f4le des diff\u00e9rentes m\u00e9thodes et l'ajouter en commentaires. Tester le code suivant : print(L.isnil()) print(L.car()) print(L.cdr().car()) Ecrire l'instruction permettant d'afficher le dernier \u00e9l\u00e9ment de la liste. Cr\u00e9er les fonctions lengthList(l) et displayList(l) qui, respectivement, compte le nombre d'\u00e9l\u00e9ments dans la liste, et affiche chacun d'entre eux. On impl\u00e9mentera ces fonctions de mani\u00e8re r\u00e9cursive . Cr\u00e9er la fonction removeList(l) , qui supprime un \u00e9l\u00e9ment en t\u00eate de liste et le retourne. Pour aller plus loin... La liste cha\u00een\u00e9e vue en cours est une liste simplement cha\u00een\u00e9e : chaque \u00e9l\u00e9ment ne poss\u00e8de qu'un lien vers le suivant. Avec une liste doublement cha\u00een\u00e9e , chaque \u00e9l\u00e9ment poss\u00e8de un lien avec le suivant et avec le pr\u00e9c\u00e9dent. Cela permet les parcours de liste dans les deux sens. On propose les classes ci-dessous pour impl\u00e9menter cette structure. Ajouter les m\u00e9thodes insereDebut et insereFin \u00e0 la classe ListeDoublementChainee , permettant d'ins\u00e9rer des \u00e9l\u00e9ments au d\u00e9but ou \u00e0 la fin de la liste. class Maillon(): def __init__(self, e): self.element = e self.suivant = None self.precedent = None class ListeDoublementChainee(): def __init__(self, m): self.maillon_debut = m","title":"B. Deuxi\u00e8me impl\u00e9mentation (POO)"},{"location":"tle/seq4/synthese/","text":"body { text-align: justify} S\u00e9quence 4 Synth\u00e8se Exercices Exercice 1 : structures et interfaces A. Quelle op\u00e9ration ne fait pas partie de l\u2019interface d\u2019une pile ? 1. ajouter un \u00e9l\u00e9ment \u00e0 la pile 2. supprimer l\u2019\u00e9l\u00e9ment le plus r\u00e9cent de la pile 3. retirer l\u2019\u00e9l\u00e9ment le plus ancien de la pile B. Quelle op\u00e9ration ne fait pas partie de l\u2019interface d\u2019une file ? 1. ajouter un \u00e9l\u00e9ment \u00e0 la file 2. supprimer l\u2019\u00e9l\u00e9ment le plus r\u00e9cent de la file 3. retirer l\u2019\u00e9l\u00e9ment le plus ancien de la file C. Pour que deux impl\u00e9mentations du m\u00eame type abstrait soient interchangeables, il faut que : 1. la complexit\u00e9 en temps soit la m\u00eame dans les deux cas 2. l\u2019interface de la structure de donn\u00e9es soit la m\u00eame dans les deux cas 3. les deux impl\u00e9mentations soient parfaitement identiques Exercice 2 : choisir une structure de donn\u00e9es Associer une structure de donn\u00e9es adapt\u00e9e \u00e0 chaque situation. - Dans une administration, on souhaite ins\u00e9rer dans une structure de donn\u00e9es les dol\u00e9ances re\u00e7ues afin de les traiter selon leur ordre d\u2019arriv\u00e9e. On aura plut\u00f4t int\u00e9r\u00eat \u00e0 les enregistrer dans : a) une liste b) une pile c) une file Pour un logiciel, on doit enregistrer la liste des actions dans une structure de donn\u00e9es de sorte \u00e0 voir la derni\u00e8re action en priorit\u00e9. On enregistrera donc les actions dans : a) une liste b) une pile c) une file On souhaite ins\u00e9rer dans une structure de donn\u00e9es les diff\u00e9rentes hauteurs d\u2019un arbre au fil des ann\u00e9es sans y ins\u00e9rer les ann\u00e9es. La structure de donn\u00e9es la plus adapt\u00e9e est : a) une liste b) une pile c) une file Exercice 3 : algorithmes sur les files et les piles Dans ces deux questions, on utilise une impl\u00e9mentation des structures en POO. On dispose d\u2019une file contenant des entiers, \u00e9crire une fonction qui renvoie une file dont on aura enlev\u00e9 les nombres impairs, mais dont les nombres pairs sont dans le m\u00eame ordre qu\u2019initialement. On dispose d\u2019une pile contenant des entiers, \u00e9crire une fonction qui renvoie une pile dont on aura enlev\u00e9 les nombres pairs, mais dont les nombres impairs sont dans le m\u00eame ordre qu\u2019initialement. Exercice 4 : synth\u00e8se Structure D\u00e9finition Cas d'utilisation Acc\u00e8s \u00e9l\u00e9ment (co\u00fbt) Ajout \u00e9l\u00e9ment (co\u00fbt) Liste cha\u00een\u00e9e Tableau statique Tableau dynamique File Pile Tableau associatif","title":"Synth\u00e8se"},{"location":"tle/seq4/synthese/#sequence-4","text":"","title":"S\u00e9quence 4"},{"location":"tle/seq4/synthese/#synthese","text":"","title":"Synth\u00e8se"},{"location":"tle/seq4/synthese/#exercices","text":"","title":"Exercices"},{"location":"tle/seq4/synthese/#exercice-1-structures-et-interfaces","text":"A. Quelle op\u00e9ration ne fait pas partie de l\u2019interface d\u2019une pile ? 1. ajouter un \u00e9l\u00e9ment \u00e0 la pile 2. supprimer l\u2019\u00e9l\u00e9ment le plus r\u00e9cent de la pile 3. retirer l\u2019\u00e9l\u00e9ment le plus ancien de la pile B. Quelle op\u00e9ration ne fait pas partie de l\u2019interface d\u2019une file ? 1. ajouter un \u00e9l\u00e9ment \u00e0 la file 2. supprimer l\u2019\u00e9l\u00e9ment le plus r\u00e9cent de la file 3. retirer l\u2019\u00e9l\u00e9ment le plus ancien de la file C. Pour que deux impl\u00e9mentations du m\u00eame type abstrait soient interchangeables, il faut que : 1. la complexit\u00e9 en temps soit la m\u00eame dans les deux cas 2. l\u2019interface de la structure de donn\u00e9es soit la m\u00eame dans les deux cas 3. les deux impl\u00e9mentations soient parfaitement identiques","title":"Exercice 1 : structures et interfaces"},{"location":"tle/seq4/synthese/#exercice-2-choisir-une-structure-de-donnees","text":"Associer une structure de donn\u00e9es adapt\u00e9e \u00e0 chaque situation. - Dans une administration, on souhaite ins\u00e9rer dans une structure de donn\u00e9es les dol\u00e9ances re\u00e7ues afin de les traiter selon leur ordre d\u2019arriv\u00e9e. On aura plut\u00f4t int\u00e9r\u00eat \u00e0 les enregistrer dans : a) une liste b) une pile c) une file Pour un logiciel, on doit enregistrer la liste des actions dans une structure de donn\u00e9es de sorte \u00e0 voir la derni\u00e8re action en priorit\u00e9. On enregistrera donc les actions dans : a) une liste b) une pile c) une file On souhaite ins\u00e9rer dans une structure de donn\u00e9es les diff\u00e9rentes hauteurs d\u2019un arbre au fil des ann\u00e9es sans y ins\u00e9rer les ann\u00e9es. La structure de donn\u00e9es la plus adapt\u00e9e est : a) une liste b) une pile c) une file","title":"Exercice 2 : choisir une structure de donn\u00e9es"},{"location":"tle/seq4/synthese/#exercice-3-algorithmes-sur-les-files-et-les-piles","text":"Dans ces deux questions, on utilise une impl\u00e9mentation des structures en POO. On dispose d\u2019une file contenant des entiers, \u00e9crire une fonction qui renvoie une file dont on aura enlev\u00e9 les nombres impairs, mais dont les nombres pairs sont dans le m\u00eame ordre qu\u2019initialement. On dispose d\u2019une pile contenant des entiers, \u00e9crire une fonction qui renvoie une pile dont on aura enlev\u00e9 les nombres pairs, mais dont les nombres impairs sont dans le m\u00eame ordre qu\u2019initialement.","title":"Exercice 3 : algorithmes sur les files et les piles"},{"location":"tle/seq4/synthese/#exercice-4-synthese","text":"Structure D\u00e9finition Cas d'utilisation Acc\u00e8s \u00e9l\u00e9ment (co\u00fbt) Ajout \u00e9l\u00e9ment (co\u00fbt) Liste cha\u00een\u00e9e Tableau statique Tableau dynamique File Pile Tableau associatif","title":"Exercice 4 : synth\u00e8se"}]}